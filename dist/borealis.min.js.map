{"version":3,"file":"borealis.min.js","sources":["../src/borealis.js"],"sourcesContent":["/**\n * Borealis - Interactive Animated Background\n * A canvas-based particle animation system with noise patterns and effects\n * \n * @author Borealis\n * @version 1.0.0\n */\n\nclass SimplexNoise {\n    constructor(seed = Math.random()) {\n        this.p = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) this.p[i] = i;\n        \n        for (let i = 255; i > 0; i--) {\n            seed = (seed * 16807) % 2147483647;\n            const j = seed % (i + 1);\n            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n        }\n        \n        this.perm = new Uint8Array(512);\n        for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];\n    }\n\n    noise2D(x, y) {\n        const F2 = 0.5 * (Math.sqrt(3) - 1);\n        const G2 = (3 - Math.sqrt(3)) / 6;\n        \n        const s = (x + y) * F2;\n        const i = Math.floor(x + s);\n        const j = Math.floor(y + s);\n        \n        const t = (i + j) * G2;\n        const X0 = i - t;\n        const Y0 = j - t;\n        const x0 = x - X0;\n        const y0 = y - Y0;\n        \n        const i1 = x0 > y0 ? 1 : 0;\n        const j1 = x0 > y0 ? 0 : 1;\n        \n        const x1 = x0 - i1 + G2;\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1 + 2 * G2;\n        const y2 = y0 - 1 + 2 * G2;\n        \n        const ii = i & 255;\n        const jj = j & 255;\n        \n        const grad = (hash, x, y) => {\n            const h = hash & 7;\n            const u = h < 4 ? x : y;\n            const v = h < 4 ? y : x;\n            return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);\n        };\n        \n        let n0 = 0, n1 = 0, n2 = 0;\n        \n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 >= 0) {\n            t0 *= t0;\n            n0 = t0 * t0 * grad(this.perm[ii + this.perm[jj]], x0, y0);\n        }\n        \n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 >= 0) {\n            t1 *= t1;\n            n1 = t1 * t1 * grad(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1);\n        }\n        \n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 >= 0) {\n            t2 *= t2;\n            n2 = t2 * t2 * grad(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2);\n        }\n        \n        return 70 * (n0 + n1 + n2);\n    }\n}\n\nclass Borealis {\n    /**\n     * Default options for Borealis\n     */\n    static get defaultOptions() {\n        return {\n            // Container & Size\n            container: document.body,\n            width: null,                    // Canvas width (null = auto from container/window)\n            height: null,                   // Canvas height (null = auto from container/window)\n            fullscreen: true,               // If true, uses fixed positioning to cover viewport\n            zIndex: 0,                      // Canvas z-index (can be any integer)\n            initiallyHidden: false,         // If true, starts collapsed/hidden\n            \n            // Grid settings\n            density: 50,                    // Grid density (10-100)\n            dotSize: 5,                     // Dot size (0-10, 0=smallest)\n            solidPattern: false,            // Solid pattern without gaps/circles\n            densityMinCell: 2,              // Cell size at max density\n            densityMaxCell: 8,              // Cell size at min density\n            densityMinGap: 1,               // Gap at max density\n            densityMaxGap: 4,               // Gap at min density\n            \n            // Pattern settings\n            patternScale: 0.001,            // Noise scale (smaller = larger patterns)\n            patternAurora: false,           // Use aurora colors for pattern\n            warpScale: 0.5,                 // Domain warp frequency multiplier\n            warpAmount: 20,                 // Domain warp intensity\n            animationSpeed: 0.00002,        // Animation speed multiplier\n            ridgePower: 2,                  // Ridge sharpness (higher = sharper lines)\n            minOpacity: 0,                  // Minimum opacity (0-1)\n            maxOpacity: 1,                  // Maximum opacity (0-1)\n            waveFrequency: 3,               // Wave oscillation frequency\n            waveAmplitude: 0.5,             // Wave intensity (0-1)\n            \n            // Effect settings (unified structure)\n            effect: {\n                type: 'wave',               // 'none', 'wave', 'twinkle'\n                aurora: false,              // Use aurora colors for effect\n                deadzone: 20,               // Center dead zone size (0-100)\n                // Wave-specific options\n                speed: 0.0008,              // Diagonal line speed\n                width: 120,                 // Width of the wave band\n                chance: 0.08,               // Chance of a cell sparkling (0-1)\n                intensity: 1,               // Max brightness\n                delayMin: 1000,             // Min delay between sweeps (ms)\n                delayMax: 3000,             // Max delay between sweeps (ms)\n                combineSparkle: false,      // Add sparkles that get boosted by wave\n                sparkleBaseOpacity: 0,      // Sparkle base opacity when wave not passing (0-100)\n                // Twinkle-specific options\n                mode: 'sparkle',            // 'sparkle' (random) or 'wave' (flowing waves)\n                combined: false,            // Combine sparkle with wave (sparkles boosted by wave)\n                baseOpacity: 30,            // Base opacity when wave is not passing (0-100)\n                twinkleSpeed: 50,           // Twinkle animation speed (10-100)\n                size: 50,                   // Pattern size (10-100)\n                density: 50,                // Star density (0-100)\n            },\n            \n            // Aurora colors\n            auroraColor1: [0, 255, 128],    // Cyan-green\n            auroraColor2: [148, 0, 211],    // Violet\n            colorScale: 0.003,              // Color variation scale\n            \n            // Collapse settings\n            collapseSpeed: 0.1,             // Collapse animation speed\n            collapseWaveWidth: 0.4,         // Width of the collapse transition\n            \n            // Animation\n            autoStart: true,                // Start animation automatically\n            \n            // Callbacks\n            onShow: null,                   // Called when show animation completes\n            onHide: null,                   // Called when hide animation completes\n        };\n    }\n\n    /**\n     * Create a new Borealis instance\n     * @param {Object} options - Configuration options\n     */\n    constructor(options = {}) {\n        // Deep merge for effect object\n        const defaultEffect = Borealis.defaultOptions.effect;\n        const userEffect = options.effect || {};\n        \n        this.options = { \n            ...Borealis.defaultOptions, \n            ...options,\n            effect: { ...defaultEffect, ...userEffect }\n        };\n        this._init();\n    }\n\n    /**\n     * Initialize the Borealis instance\n     * @private\n     */\n    _init() {\n        // Create canvas\n        this.canvas = document.createElement('canvas');\n        \n        // Set canvas styles based on mode\n        const zIndex = this.options.zIndex;\n        if (this.options.fullscreen) {\n            this.canvas.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n            `;\n        } else {\n            this.canvas.style.cssText = `\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n            `;\n        }\n        \n        // Add to container\n        const container = this.options.container;\n        if (container === document.body && this.options.fullscreen) {\n            document.body.insertBefore(this.canvas, document.body.firstChild);\n        } else {\n            // Ensure container has position for absolute positioning\n            const containerStyle = window.getComputedStyle(container);\n            if (containerStyle.position === 'static') {\n                container.style.position = 'relative';\n            }\n            container.appendChild(this.canvas);\n        }\n        \n        this.ctx = this.canvas.getContext('2d');\n        this.noise = new SimplexNoise(Math.random() * 10000);\n        this.randomOffset = Math.random() * 1000;\n        \n        // Internal state\n        this._cellSize = 4;\n        this._gap = 2;\n        this._gridSize = 6;\n        this._sparkleMap = {};\n        this._animTime = 0;\n        this._twinkleTime = 0;\n        this._lastFrameTime = 0;\n        this._sparkleWaiting = false;\n        this._sparkleWaitUntil = 0;\n        this._diagPos = 0;\n        this._isCollapsing = this.options.initiallyHidden;  // Stay collapsed until manual show() call\n        this._collapseProgress = this.options.initiallyHidden ? 1 + this.options.collapseWaveWidth : 0;  // Start fully hidden if initiallyHidden is true\n        this._isRunning = false;\n        this._animationId = null;\n        \n        // Computed twinkle values\n        this._twinkleThreshold = 0.8;\n        this._twinkleSpeedValue = 3;\n        this._twinkleScaleValue = 0.01;\n        this._deadzoneValue = 0.2;\n        \n        // Apply initial options\n        this._updateDensity(this.options.density);\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        \n        // Bind methods\n        this._draw = this._draw.bind(this);\n        this._resize = this._resize.bind(this);\n        \n        // Setup event listeners\n        window.addEventListener('resize', this._resize);\n        \n        // Initial resize\n        this._resize();\n        \n        // Auto start\n        if (this.options.autoStart) {\n            this.start();\n        }\n    }\n\n    /**\n     * Update density settings\n     * @private\n     */\n    _updateDensity(value) {\n        const t = (100 - value) / 90;\n        const baseCell = this.options.densityMinCell + t * (this.options.densityMaxCell - this.options.densityMinCell);\n        // Apply dotSize multiplier (0 = 0.3x, 5 = 1x, 10 = 2x)\n        const sizeMultiplier = 0.3 + (this.options.dotSize / 10) * 1.7;\n        this._cellSize = baseCell * sizeMultiplier;\n        this._gap = this.options.densityMinGap + t * (this.options.densityMaxGap - this.options.densityMinGap);\n        this._gridSize = this._cellSize + this._gap;\n    }\n\n    /**\n     * Update twinkle settings from options\n     * @private\n     */\n    _updateTwinkleSettings() {\n        const effect = this.options.effect;\n        // Speed: 10-100 maps to 1-6\n        this._twinkleSpeedValue = 1 + (effect.twinkleSpeed - 10) / 90 * 5;\n        // Size: 10-100 maps to 0.5-0.001 (inverted, much wider range)\n        this._twinkleScaleValue = 0.5 - (effect.size - 10) / 90 * 0.499;\n        // Density: 0-100 maps to threshold 1.0-0.1\n        this._twinkleThreshold = 1 - effect.density / 100 * 0.9;\n    }\n\n    /**\n     * Update deadzone setting (applies to all effects)\n     * @private\n     */\n    _updateDeadzone() {\n        // Deadzone: 0-100 maps to 0-1 (percentage of diagonal distance from center to corner)\n        this._deadzoneValue = this.options.effect.deadzone / 100;\n    }\n\n    /**\n     * Generate sparkle map\n     * @private\n     */\n    _generateSparkles(cols, rows) {\n        this._sparkleMap = {};\n        for (let y = 0; y < rows; y++) {\n            for (let x = 0; x < cols; x++) {\n                if (Math.random() < this.options.effect.chance) {\n                    this._sparkleMap[`${x},${y}`] = Math.random();\n                }\n            }\n        }\n    }\n\n    /**\n     * Resize handler\n     * @private\n     */\n    _resize() {\n        // Determine dimensions\n        let width, height;\n        \n        if (this.options.width !== null && this.options.height !== null) {\n            // Use explicit dimensions\n            width = this.options.width;\n            height = this.options.height;\n        } else if (this.options.fullscreen) {\n            // Use window dimensions\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            // Use container dimensions\n            const container = this.options.container;\n            width = this.options.width !== null ? this.options.width : container.clientWidth;\n            height = this.options.height !== null ? this.options.height : container.clientHeight;\n        }\n        \n        this.canvas.width = width;\n        this.canvas.height = height;\n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        this._generateSparkles(cols, rows);\n        // Clear offscreen canvas cache on resize\n        this._offscreenCanvas = null;\n        this._offscreenCtx = null;\n    }\n\n    /**\n     * Main draw loop\n     * @private\n     */\n    _draw(time) {\n        if (!this._isRunning) return;\n        \n        const delta = time - this._lastFrameTime;\n        \n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        // Handle wave timing\n        const effect = this.options.effect;\n        if (!this._sparkleWaiting) {\n            this._diagPos += delta * effect.speed * 100;\n            \n            const cols = Math.ceil(this.canvas.width / this._gridSize);\n            const rows = Math.ceil(this.canvas.height / this._gridSize);\n            const maxDiag = cols + rows;\n            \n            if (this._diagPos > maxDiag + effect.width) {\n                this._sparkleWaiting = true;\n                const delay = effect.delayMin + Math.random() * (effect.delayMax - effect.delayMin);\n                this._sparkleWaitUntil = time + delay;\n                this._generateSparkles(cols, rows);\n            }\n        } else {\n            if (time >= this._sparkleWaitUntil) {\n                this._sparkleWaiting = false;\n                this._diagPos = -effect.width;\n            }\n        }\n        \n        this._lastFrameTime = time;\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        // For solid pattern, use offscreen canvas for pixel-perfect base pattern\n        if (this.options.solidPattern) {\n            // Create or reuse offscreen canvas at grid resolution\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            // Draw only base pattern to ImageData (no effects)\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    \n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            \n            // Scale up to full canvas size with smooth interpolation\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            // Draw effects on top using regular canvas API (crisp circles)\n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        // Update collapse\n        this._updateCollapse();\n        \n        this._animationId = requestAnimationFrame(this._draw);\n    }\n\n    /**\n     * Calculate cell data for solid pattern (used for ImageData rendering)\n     * @private\n     */\n    _calculateCellData(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Pattern color (no effects in solid pattern base - effects drawn separately)\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse (only base pattern, no effect)\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, 0);\n            opacity = collapseResult.opacity;\n        }\n        \n        return { r, g, b, opacity };\n    }\n\n    /**\n     * Draw only effect for a cell (used in solid pattern mode)\n     * @private\n     */\n    _drawEffect(x, y, cols, rows) {\n        const effect = this.options.effect;\n        \n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, 0, effectOpacity);\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Draw effect circle if visible\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Draw a single cell\n     * @private\n     */\n    _drawCell(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Effect variables\n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (options.effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (options.effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Pattern color\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, effectOpacity);\n            opacity = collapseResult.opacity;\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Skip rendering if both opacities are 0 (performance optimization)\n        if (opacity <= 0 && effectOpacity <= 0) {\n            return;\n        }\n        \n        // Draw base pattern\n        this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;\n        if (this.options.solidPattern) {\n            // Solid mode: fill entire cell without gaps (add 0.5px overlap to prevent gaps)\n            const px = Math.floor(x * this._gridSize);\n            const py = Math.floor(y * this._gridSize);\n            this.ctx.fillRect(px, py, Math.ceil(this._gridSize) + 1, Math.ceil(this._gridSize) + 1);\n        } else {\n            // Circle mode\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        \n        // Draw effect on top (always circles)\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Calculate wave effect\n     * @private\n     */\n    _calculateWaveEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        // Combined sparkle mode - sparkles that get boosted by wave\n        if (effect.combineSparkle && centerFade > 0) {\n            // Calculate wave proximity (0-1, 1 = wave is here)\n            const cellDiag = x + y;\n            const distFromLine = Math.abs(cellDiag - this._diagPos);\n            // Narrower wave effect zone for more dramatic boost\n            const waveProximity = Math.max(0, 1 - distFromLine / effect.width);\n            // Sharper falloff - wave effect drops quickly\n            const smoothWaveProximity = Math.pow(waveProximity, 0.5);\n            \n            // Calculate sparkle\n            const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n            const rand1 = hash1 - Math.floor(hash1);\n            const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n            const rand2 = hash2 - Math.floor(hash2);\n            \n            // Use twinkle density for sparkle distribution\n            const sparkleThreshold = 1 - effect.density / 100 * 0.9;\n            \n            if (rand1 > sparkleThreshold) {\n                const phase = rand2 * Math.PI * 2;\n                const sparkleSpeed = 0.1 + (effect.twinkleSpeed / 100) * 0.4;\n                const twinkleWave = Math.sin(_twinkleTime * sparkleSpeed + phase);\n                const sparkle = Math.max(0, twinkleWave);\n                \n                // Base opacity is limited, wave boosts it to full\n                const baseOpacity = effect.sparkleBaseOpacity / 100;\n                const maxBoost = 1 - baseOpacity;\n                const finalOpacity = baseOpacity + (maxBoost * smoothWaveProximity);\n                \n                opacity = sparkle * finalOpacity * centerFade;\n                \n                if (effect.aurora) {\n                    const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                    const colorBlend = colorRand - Math.floor(colorRand);\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            }\n            \n            return { color, opacity };\n        }\n        \n        const cellDiag = x + y;\n        const distFromLine = Math.abs(cellDiag - this._diagPos);\n        \n        if (distFromLine < effect.width && this._sparkleMap[`${x},${y}`] !== undefined) {\n            const normalizedDist = distFromLine / effect.width;\n            const sparkle = Math.cos(normalizedDist * Math.PI * 0.5) * effect.intensity;\n            \n            // Cylinder effect\n            const fullDiagonalLength = Math.min(cols, rows);\n            const diagStartX = Math.max(0, Math.floor(this._diagPos) - (rows - 1));\n            const diagEndX = Math.min(cols - 1, Math.floor(this._diagPos));\n            const currentLineLength = Math.max(1, diagEndX - diagStartX + 1);\n            \n            let cylinderFade = 1;\n            if (currentLineLength >= fullDiagonalLength && currentLineLength > 1) {\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                cylinderFade = 0.3 + 0.7 * Math.sin(clampedPos * Math.PI);\n            } else if (currentLineLength > 1) {\n                const completeness = currentLineLength / fullDiagonalLength;\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                const baseFade = Math.sin(clampedPos * Math.PI);\n                cylinderFade = Math.max(0.3, 1 - (1 - baseFade) * completeness * 0.7);\n            }\n            \n            opacity = sparkle * this._sparkleMap[`${x},${y}`] * Math.max(0, cylinderFade) * centerFade;\n            \n            // Color\n            if (effect.aurora) {\n                const colorNoise = noise.noise2D(x * options.colorScale * 2 + randomOffset, y * options.colorScale * 2 + _animTime + randomOffset);\n                const colorBlend = (colorNoise + 1) / 2;\n                color = [\n                    Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                    Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                    Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                ];\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Calculate twinkle effect\n     * @private\n     */\n    _calculateTwinkleEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        if (centerFade > 0) {\n            // Combined mode - sparkles that get boosted by passing waves\n            if (effect.combined) {\n                // Calculate wave intensity first\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                const waveIntensity = Math.pow(smoothWave, 0.5); // Smoother wave\n                \n                // Calculate sparkle\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue * 2 + phase);\n                    const sparkle = Math.max(0, twinkleWave);\n                    \n                    // Base opacity is limited, wave boosts it to full\n                    const baseOpacity = effect.baseOpacity / 100;\n                    const maxBoost = 1 - baseOpacity;\n                    const finalOpacity = baseOpacity + (maxBoost * waveIntensity);\n                    \n                    opacity = sparkle * finalOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n            // Wave mode - flowing waves that boost opacity to 100%\n            else if (effect.mode === 'wave') {\n                // Create smooth, wide flowing light bands\n                // Size controls the width of the bands\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                // Slow, smooth primary wave - creates wide bands\n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                \n                // Very slow secondary wave for organic variation\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                \n                // Third wave for extra organic feel\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                // Combine waves smoothly\n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                \n                // Smooth sine-based intensity (no harsh ridges)\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                \n                // Apply density as band width control\n                const densityFactor = 0.3 + this._twinkleThreshold * 0.7;\n                const intensity = Math.pow(smoothWave, 1 / densityFactor);\n                \n                // Smooth the final output\n                opacity = intensity * effect.intensity * centerFade;\n                \n                // Aurora colors for wave mode\n                if (effect.aurora && opacity > 0) {\n                    const colorWave = noise.noise2D(\n                        x * baseScale * 0.3 + _twinkleTime * waveSpeed * 0.1 + randomOffset,\n                        y * baseScale * 0.3 + randomOffset\n                    );\n                    const colorBlend = (colorWave + 1) / 2;\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            } else {\n                // Sparkle mode - original random twinkling\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                \n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue + phase);\n                    const baseBrightness = Math.max(0, twinkleWave);\n                    \n                    const groupWave = noise.noise2D(\n                        x * this._twinkleScaleValue + _twinkleTime * 0.2 + randomOffset,\n                        y * this._twinkleScaleValue + randomOffset\n                    );\n                    const maxOpacity = 0.2 + (groupWave + 1) / 2 * 0.8;\n                    \n                    opacity = baseBrightness * maxOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Apply collapse effect\n     * @private\n     */\n    _applyCollapse(x, y, cols, rows, opacity, effectOpacity) {\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const normalizedDist = distFromCenter / maxRadius;\n        \n        const collapseAt = 1 - normalizedDist;\n        \n        if (this._collapseProgress > collapseAt + this.options.collapseWaveWidth) {\n            opacity = 0;\n            effectOpacity = 0;\n        } else if (this._collapseProgress > collapseAt) {\n            const t = 1 - (this._collapseProgress - collapseAt) / this.options.collapseWaveWidth;\n            const smoothFade = t * t * (3 - 2 * t);\n            opacity *= smoothFade;\n            effectOpacity *= smoothFade;\n        }\n        \n        return { opacity, effectOpacity };\n    }\n\n    /**\n     * Update collapse animation\n     * @private\n     */\n    _updateCollapse() {\n        const collapseEnd = 1 + this.options.collapseWaveWidth;\n        \n        if (this._isCollapsing && this._collapseProgress < collapseEnd) {\n            this._collapseProgress += this.options.collapseSpeed;\n            if (this._collapseProgress >= collapseEnd) {\n                this._collapseProgress = collapseEnd;\n                if (this.options.onHide) {\n                    this.options.onHide();\n                }\n            }\n        } else if (!this._isCollapsing && this._collapseProgress > 0) {\n            this._collapseProgress -= this.options.collapseSpeed;\n            if (this._collapseProgress <= 0) {\n                this._collapseProgress = 0;\n                if (this.options.onShow) {\n                    this.options.onShow();\n                }\n            }\n        }\n    }\n\n    // ==================== PUBLIC API ====================\n\n    /**\n     * Start the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    start() {\n        if (!this._isRunning) {\n            this._isRunning = true;\n            this._lastFrameTime = performance.now();\n            this._animationId = requestAnimationFrame(this._draw);\n        }\n        return this;\n    }\n\n    /**\n     * Stop the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    stop() {\n        this._isRunning = false;\n        if (this._animationId) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = null;\n        }\n        return this;\n    }\n\n    /**\n     * Manually trigger a resize (useful when container size changes)\n     * @param {number} [width] - Optional new width\n     * @param {number} [height] - Optional new height\n     * @returns {Borealis} this instance for chaining\n     */\n    resize(width, height) {\n        if (width !== undefined) {\n            this.options.width = width;\n        }\n        if (height !== undefined) {\n            this.options.height = height;\n        }\n        this._resize();\n        return this;\n    }\n\n    /**\n     * Force a single frame redraw (useful when animation is stopped)\n     * @returns {Borealis} this instance for chaining\n     */\n    redraw() {\n        const time = performance.now();\n        const wasRunning = this._isRunning;\n        this._isRunning = true;\n        this._lastFrameTime = time - 16; // Simulate ~60fps frame\n        \n        // Draw single frame without requesting next\n        const delta = 16;\n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        if (this.options.solidPattern) {\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        this._isRunning = wasRunning;\n        return this;\n    }\n\n    /**\n     * Show the pattern (expand from center)\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    show(callback) {\n        this._isCollapsing = false;\n        if (callback) {\n            const originalCallback = this.options.onShow;\n            this.options.onShow = () => {\n                callback();\n                this.options.onShow = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Hide the pattern (collapse to center)\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    hide(callback) {\n        this._isCollapsing = true;\n        if (callback) {\n            const originalCallback = this.options.onHide;\n            this.options.onHide = () => {\n                callback();\n                this.options.onHide = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Toggle between show and hide\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    toggle(callback) {\n        if (this._isCollapsing) {\n            return this.show(callback);\n        } else {\n            return this.hide(callback);\n        }\n    }\n\n    /**\n     * Check if currently visible (not collapsed)\n     * @returns {boolean}\n     */\n    isVisible() {\n        return !this._isCollapsing && this._collapseProgress === 0;\n    }\n\n    /**\n     * Check if currently hidden (fully collapsed)\n     * @returns {boolean}\n     */\n    isHidden() {\n        return this._isCollapsing && this._collapseProgress >= 1 + this.options.collapseWaveWidth;\n    }\n\n    /**\n     * Set a single option\n     * @param {string} key - Option key\n     * @param {*} value - Option value\n     * @returns {Borealis} this instance for chaining\n     */\n    setOption(key, value) {\n        // Handle effect as special case (use setEffect instead)\n        if (key === 'effect') {\n            if (typeof value === 'object') {\n                return this.setEffect(value.type, value);\n            }\n            return this;\n        }\n        \n        this.options[key] = value;\n        \n        // Handle special cases that need resize/recalculation\n        const needsResize = [\n            'density', 'dotSize', 'solidPattern', 'patternAurora', \n            'maxOpacity', 'minOpacity'\n        ];\n        \n        if (needsResize.includes(key)) {\n            this._updateDensity(this.options.density);\n            this._resize();\n        }\n        \n        return this;\n    }\n\n    /**\n     * Set effect type and options\n     * @param {string} type - Effect type: 'none', 'wave', or 'twinkle'\n     * @param {Object} [effectOptions] - Effect-specific options\n     * @returns {Borealis} this instance for chaining\n     */\n    setEffect(type, effectOptions = {}) {\n        // Update effect type\n        if (type) {\n            this.options.effect.type = type;\n        }\n        \n        // Merge effect options\n        Object.keys(effectOptions).forEach(key => {\n            if (key !== 'type') {\n                this.options.effect[key] = effectOptions[key];\n            }\n        });\n        \n        // Update internal computed values\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        this._resize();\n        \n        return this;\n    }\n\n    /**\n     * Get current effect configuration\n     * @returns {Object} Effect configuration with type and options\n     */\n    getEffect() {\n        return { ...this.options.effect };\n    }\n\n    /**\n     * Set multiple options at once\n     * @param {Object} options - Options object\n     * @returns {Borealis} this instance for chaining\n     */\n    setOptions(options) {\n        Object.keys(options).forEach(key => {\n            this.setOption(key, options[key]);\n        });\n        return this;\n    }\n\n    /**\n     * Get current options\n     * @returns {Object} Current options\n     */\n    getOptions() {\n        return { ...this.options };\n    }\n\n    /**\n     * Get a specific option value\n     * @param {string} key - Option key\n     * @returns {*} Option value\n     */\n    getOption(key) {\n        return this.options[key];\n    }\n\n    /**\n     * Destroy the instance and clean up\n     */\n    destroy() {\n        this.stop();\n        window.removeEventListener('resize', this._resize);\n        \n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n        \n        this.canvas = null;\n        this.ctx = null;\n        this.noise = null;\n    }\n}\n\nexport default Borealis;\n"],"names":["SimplexNoise","constructor","seed","Math","random","this","p","Uint8Array","i","j","perm","noise2D","x","y","F2","sqrt","G2","s","floor","t","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","grad","hash","h","u","v","n0","n1","n2","t0","t1","t2","Borealis","defaultOptions","container","document","body","width","height","fullscreen","zIndex","initiallyHidden","density","dotSize","solidPattern","densityMinCell","densityMaxCell","densityMinGap","densityMaxGap","patternScale","patternAurora","warpScale","warpAmount","animationSpeed","ridgePower","minOpacity","maxOpacity","waveFrequency","waveAmplitude","effect","type","aurora","deadzone","speed","chance","intensity","delayMin","delayMax","combineSparkle","sparkleBaseOpacity","mode","combined","baseOpacity","twinkleSpeed","size","auroraColor1","auroraColor2","colorScale","collapseSpeed","collapseWaveWidth","autoStart","onShow","onHide","options","defaultEffect","userEffect","_init","canvas","createElement","style","cssText","insertBefore","firstChild","window","getComputedStyle","position","appendChild","ctx","getContext","noise","randomOffset","_cellSize","_gap","_gridSize","_sparkleMap","_animTime","_twinkleTime","_lastFrameTime","_sparkleWaiting","_sparkleWaitUntil","_diagPos","_isCollapsing","_collapseProgress","_isRunning","_animationId","_twinkleThreshold","_twinkleSpeedValue","_twinkleScaleValue","_deadzoneValue","_updateDensity","_updateTwinkleSettings","_updateDeadzone","_draw","bind","_resize","addEventListener","start","value","baseCell","sizeMultiplier","_generateSparkles","cols","rows","innerWidth","innerHeight","clientWidth","clientHeight","ceil","_offscreenCanvas","_offscreenCtx","time","delta","maxDiag","delay","clearRect","offCtx","imageData","createImageData","data","cellData","_calculateCellData","idx","r","g","b","round","opacity","putImageData","imageSmoothingEnabled","imageSmoothingQuality","drawImage","_drawEffect","_drawCell","_updateCollapse","requestAnimationFrame","wave1","sin","wave2","cos","warpX","warpY","noiseVal","ridge","abs","rawOpacity","pow","colorBlend","_applyCollapse","effectColor","effectOpacity","result","_calculateWaveEffect","color","_calculateTwinkleEffect","fillStyle","beginPath","arc","PI","fill","collapseResult","px","py","fillRect","centerX","centerY","distFromCenter","maxRadius","fadeZone","centerFade","cellDiag","distFromLine","waveProximity","max","smoothWaveProximity","hash1","rand1","hash2","rand2","phase","sparkleSpeed","twinkleWave","sparkle","colorRand","undefined","normalizedDist","fullDiagonalLength","min","diagStartX","diagEndX","currentLineLength","cylinderFade","posAlongLine","clampedPos","completeness","baseFade","baseScale","waveSpeed","smoothWave","waveIntensity","densityFactor","collapseAt","smoothFade","collapseEnd","performance","now","stop","cancelAnimationFrame","resize","redraw","wasRunning","show","callback","originalCallback","hide","toggle","isVisible","isHidden","setOption","key","setEffect","includes","effectOptions","Object","keys","forEach","getEffect","setOptions","getOptions","getOption","destroy","removeEventListener","parentNode","removeChild"],"mappings":"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"}