{"version":3,"file":"borealis.min.js","sources":["../src/borealis.js"],"sourcesContent":["/**\n * Borealis - Interactive Animated Background\n * A canvas-based particle animation system with noise patterns and effects\n * \n * @author Borealis\n * @version 1.0.0\n */\n\nclass SimplexNoise {\n    constructor(seed = Math.random()) {\n        this.p = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) this.p[i] = i;\n        \n        for (let i = 255; i > 0; i--) {\n            seed = (seed * 16807) % 2147483647;\n            const j = seed % (i + 1);\n            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n        }\n        \n        this.perm = new Uint8Array(512);\n        for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];\n    }\n\n    noise2D(x, y) {\n        const F2 = 0.5 * (Math.sqrt(3) - 1);\n        const G2 = (3 - Math.sqrt(3)) / 6;\n        \n        const s = (x + y) * F2;\n        const i = Math.floor(x + s);\n        const j = Math.floor(y + s);\n        \n        const t = (i + j) * G2;\n        const X0 = i - t;\n        const Y0 = j - t;\n        const x0 = x - X0;\n        const y0 = y - Y0;\n        \n        const i1 = x0 > y0 ? 1 : 0;\n        const j1 = x0 > y0 ? 0 : 1;\n        \n        const x1 = x0 - i1 + G2;\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1 + 2 * G2;\n        const y2 = y0 - 1 + 2 * G2;\n        \n        const ii = i & 255;\n        const jj = j & 255;\n        \n        const grad = (hash, x, y) => {\n            const h = hash & 7;\n            const u = h < 4 ? x : y;\n            const v = h < 4 ? y : x;\n            return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);\n        };\n        \n        let n0 = 0, n1 = 0, n2 = 0;\n        \n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 >= 0) {\n            t0 *= t0;\n            n0 = t0 * t0 * grad(this.perm[ii + this.perm[jj]], x0, y0);\n        }\n        \n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 >= 0) {\n            t1 *= t1;\n            n1 = t1 * t1 * grad(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1);\n        }\n        \n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 >= 0) {\n            t2 *= t2;\n            n2 = t2 * t2 * grad(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2);\n        }\n        \n        return 70 * (n0 + n1 + n2);\n    }\n}\n\nclass Borealis {\n    /**\n     * Default options for Borealis\n     */\n    static get defaultOptions() {\n        return {\n            // Container & Size\n            container: document.body,\n            width: null,                    // Canvas width (null = auto from container/window)\n            height: null,                   // Canvas height (null = auto from container/window)\n            fullscreen: true,               // If true, uses fixed positioning to cover viewport\n            zIndex: 0,                      // Canvas z-index (can be any integer)\n            initiallyHidden: false,         // If true, starts collapsed/hidden\n            className: null,                // Custom class name for canvas\n            background: null,               // Canvas background (color, gradient, etc.)\n            \n            // Grid settings\n            density: 50,                    // Grid density (10-100)\n            dotSize: 5,                     // Dot size (0-10, 0=smallest)\n            solidPattern: false,            // Solid pattern without gaps/circles\n            densityMinCell: 2,              // Cell size at max density\n            densityMaxCell: 8,              // Cell size at min density\n            densityMinGap: 1,               // Gap at max density\n            densityMaxGap: 4,               // Gap at min density\n            \n            // Pattern settings\n            patternScale: 0.001,            // Noise scale (smaller = larger patterns)\n            patternAurora: false,           // Use aurora colors for pattern\n            warpScale: 0.5,                 // Domain warp frequency multiplier\n            warpAmount: 20,                 // Domain warp intensity\n            animationSpeed: 0.00002,        // Animation speed multiplier\n            ridgePower: 2,                  // Ridge sharpness (higher = sharper lines)\n            minOpacity: 0,                  // Minimum opacity (0-1)\n            maxOpacity: 1,                  // Maximum opacity (0-1)\n            waveFrequency: 3,               // Wave oscillation frequency\n            waveAmplitude: 0.5,             // Wave intensity (0-1)\n            \n            // Effect settings (unified structure)\n            effect: {\n                type: 'wave',               // 'none', 'wave', 'twinkle'\n                aurora: false,              // Use aurora colors for effect\n                deadzone: 20,               // Center dead zone size (0-100)\n                // Wave-specific options\n                speed: 0.0008,              // Diagonal line speed\n                width: 120,                 // Width of the wave band\n                chance: 0.08,               // Chance of a cell sparkling (0-1)\n                intensity: 1,               // Max brightness\n                delayMin: 1000,             // Min delay between sweeps (ms)\n                delayMax: 3000,             // Max delay between sweeps (ms)\n                combineSparkle: false,      // Add sparkles that get boosted by wave\n                sparkleBaseOpacity: 0,      // Sparkle base opacity when wave not passing (0-100)\n                // Twinkle-specific options\n                mode: 'sparkle',            // 'sparkle' (random) or 'wave' (flowing waves)\n                combined: false,            // Combine sparkle with wave (sparkles boosted by wave)\n                baseOpacity: 30,            // Base opacity when wave is not passing (0-100)\n                twinkleSpeed: 50,           // Twinkle animation speed (10-100)\n                size: 50,                   // Pattern size (10-100)\n                density: 50,                // Star density (0-100)\n            },\n            \n            // Aurora colors\n            auroraColor1: [0, 255, 128],    // Cyan-green\n            auroraColor2: [148, 0, 211],    // Violet\n            colorScale: 0.003,              // Color variation scale\n            \n            // Collapse settings\n            collapseSpeed: 0.1,             // Collapse animation speed (used when duration not specified)\n            collapseWaveWidth: 0.4,         // Width of the collapse transition\n            showDuration: null,             // Show animation duration in ms (null = use collapseSpeed)\n            hideDuration: null,             // Hide animation duration in ms (null = use collapseSpeed)\n            fadeOpacity: true,              // Fade canvas opacity during show/hide animations\n            revealingClass: 'borealis-revealing', // Class added during show animation\n            visibleClass: 'borealis-visible',     // Class added when fully visible\n            hidingClass: 'borealis-hiding',       // Class added during hide animation\n            hiddenClass: 'borealis-hidden',       // Class added when fully hidden\n            \n            // Animation\n            autoStart: true,                // Start animation automatically\n            \n            // Callbacks\n            onShow: null,                   // Called when show animation completes\n            onHide: null,                   // Called when hide animation completes\n        };\n    }\n\n    /**\n     * Create a new Borealis instance\n     * @param {Object} options - Configuration options\n     */\n    constructor(options = {}) {\n        // Deep merge for effect object\n        const defaultEffect = Borealis.defaultOptions.effect;\n        const userEffect = options.effect || {};\n        \n        this.options = { \n            ...Borealis.defaultOptions, \n            ...options,\n            effect: { ...defaultEffect, ...userEffect }\n        };\n        this._init();\n    }\n\n    /**\n     * Initialize the Borealis instance\n     * @private\n     */\n    _init() {\n        // Create canvas\n        this.canvas = document.createElement('canvas');\n        \n        // Set custom class name if provided\n        if (this.options.className) {\n            this.canvas.className = this.options.className;\n        }\n        \n        // Set canvas styles based on mode\n        const zIndex = this.options.zIndex;\n        const background = this.options.background ? `background: ${this.options.background};` : '';\n        if (this.options.fullscreen) {\n            this.canvas.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n                ${background}\n            `;\n        } else {\n            this.canvas.style.cssText = `\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n                ${background}\n            `;\n        }\n        \n        // Add to container\n        const container = this.options.container;\n        if (container === document.body && this.options.fullscreen) {\n            document.body.insertBefore(this.canvas, document.body.firstChild);\n        } else {\n            // Ensure container has position for absolute positioning\n            const containerStyle = window.getComputedStyle(container);\n            if (containerStyle.position === 'static') {\n                container.style.position = 'relative';\n            }\n            container.appendChild(this.canvas);\n        }\n        \n        this.ctx = this.canvas.getContext('2d');\n        this.noise = new SimplexNoise(Math.random() * 10000);\n        this.randomOffset = Math.random() * 1000;\n        \n        // Internal state\n        this._cellSize = 4;\n        this._gap = 2;\n        this._gridSize = 6;\n        this._sparkleMap = {};\n        this._animTime = 0;\n        this._twinkleTime = 0;\n        this._lastFrameTime = 0;\n        this._sparkleWaiting = false;\n        this._sparkleWaitUntil = 0;\n        this._diagPos = 0;\n        this._isCollapsing = this.options.initiallyHidden;  // Stay collapsed until manual show() call\n        this._collapseProgress = this.options.initiallyHidden ? 1 + this.options.collapseWaveWidth : 0;  // Start fully hidden if initiallyHidden is true\n        this._isRunning = false;\n        this._animationId = null;\n        this._showSpeed = null;\n        this._hideSpeed = null;\n        \n        // Set initial CSS class and opacity based on initiallyHidden\n        if (this.options.initiallyHidden) {\n            if (this.options.hiddenClass) this.canvas.classList.add(this.options.hiddenClass);\n            if (this.options.fadeOpacity) this.canvas.style.opacity = 0;\n        } else {\n            if (this.options.visibleClass) this.canvas.classList.add(this.options.visibleClass);\n            if (this.options.fadeOpacity) this.canvas.style.opacity = 1;\n        }\n        \n        // Computed twinkle values\n        this._twinkleThreshold = 0.8;\n        this._twinkleSpeedValue = 3;\n        this._twinkleScaleValue = 0.01;\n        this._deadzoneValue = 0.2;\n        \n        // Apply initial options\n        this._updateDensity(this.options.density);\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        \n        // Bind methods\n        this._draw = this._draw.bind(this);\n        this._resize = this._resize.bind(this);\n        \n        // Setup event listeners\n        window.addEventListener('resize', this._resize);\n        \n        // Initial resize\n        this._resize();\n        \n        // Auto start\n        if (this.options.autoStart) {\n            this.start();\n        }\n    }\n\n    /**\n     * Update density settings\n     * @private\n     */\n    _updateDensity(value) {\n        const t = (100 - value) / 90;\n        const baseCell = this.options.densityMinCell + t * (this.options.densityMaxCell - this.options.densityMinCell);\n        // Apply dotSize multiplier (0 = 0.3x, 5 = 1x, 10 = 2x)\n        const sizeMultiplier = 0.3 + (this.options.dotSize / 10) * 1.7;\n        this._cellSize = baseCell * sizeMultiplier;\n        this._gap = this.options.densityMinGap + t * (this.options.densityMaxGap - this.options.densityMinGap);\n        this._gridSize = this._cellSize + this._gap;\n    }\n\n    /**\n     * Update twinkle settings from options\n     * @private\n     */\n    _updateTwinkleSettings() {\n        const effect = this.options.effect;\n        // Speed: 10-100 maps to 1-6\n        this._twinkleSpeedValue = 1 + (effect.twinkleSpeed - 10) / 90 * 5;\n        // Size: 10-100 maps to 0.5-0.001 (inverted, much wider range)\n        this._twinkleScaleValue = 0.5 - (effect.size - 10) / 90 * 0.499;\n        // Density: 0-100 maps to threshold 1.0-0.1\n        this._twinkleThreshold = 1 - effect.density / 100 * 0.9;\n    }\n\n    /**\n     * Update deadzone setting (applies to all effects)\n     * @private\n     */\n    _updateDeadzone() {\n        // Deadzone: 0-100 maps to 0-1 (percentage of diagonal distance from center to corner)\n        this._deadzoneValue = this.options.effect.deadzone / 100;\n    }\n\n    /**\n     * Generate sparkle map\n     * @private\n     */\n    _generateSparkles(cols, rows) {\n        this._sparkleMap = {};\n        for (let y = 0; y < rows; y++) {\n            for (let x = 0; x < cols; x++) {\n                if (Math.random() < this.options.effect.chance) {\n                    this._sparkleMap[`${x},${y}`] = Math.random();\n                }\n            }\n        }\n    }\n\n    /**\n     * Resize handler\n     * @private\n     */\n    _resize() {\n        // Determine dimensions\n        let width, height;\n        \n        if (this.options.width !== null && this.options.height !== null) {\n            // Use explicit dimensions\n            width = this.options.width;\n            height = this.options.height;\n        } else if (this.options.fullscreen) {\n            // Use window dimensions\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            // Use container dimensions\n            const container = this.options.container;\n            width = this.options.width !== null ? this.options.width : container.clientWidth;\n            height = this.options.height !== null ? this.options.height : container.clientHeight;\n        }\n        \n        this.canvas.width = width;\n        this.canvas.height = height;\n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        this._generateSparkles(cols, rows);\n        // Clear offscreen canvas cache on resize\n        this._offscreenCanvas = null;\n        this._offscreenCtx = null;\n    }\n\n    /**\n     * Main draw loop\n     * @private\n     */\n    _draw(time) {\n        if (!this._isRunning) return;\n        \n        const delta = time - this._lastFrameTime;\n        \n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        // Handle wave timing\n        const effect = this.options.effect;\n        if (!this._sparkleWaiting) {\n            this._diagPos += delta * effect.speed * 100;\n            \n            const cols = Math.ceil(this.canvas.width / this._gridSize);\n            const rows = Math.ceil(this.canvas.height / this._gridSize);\n            const maxDiag = cols + rows;\n            \n            if (this._diagPos > maxDiag + effect.width) {\n                this._sparkleWaiting = true;\n                const delay = effect.delayMin + Math.random() * (effect.delayMax - effect.delayMin);\n                this._sparkleWaitUntil = time + delay;\n                this._generateSparkles(cols, rows);\n            }\n        } else {\n            if (time >= this._sparkleWaitUntil) {\n                this._sparkleWaiting = false;\n                this._diagPos = -effect.width;\n            }\n        }\n        \n        this._lastFrameTime = time;\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        // For solid pattern, use offscreen canvas for pixel-perfect base pattern\n        if (this.options.solidPattern) {\n            // Create or reuse offscreen canvas at grid resolution\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            // Draw only base pattern to ImageData (no effects)\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    \n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            \n            // Scale up to full canvas size with smooth interpolation\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            // Draw effects on top using regular canvas API (crisp circles)\n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        // Update collapse\n        this._updateCollapse();\n        \n        this._animationId = requestAnimationFrame(this._draw);\n    }\n\n    /**\n     * Calculate cell data for solid pattern (used for ImageData rendering)\n     * @private\n     */\n    _calculateCellData(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Pattern color (no effects in solid pattern base - effects drawn separately)\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse (only base pattern, no effect)\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, 0);\n            opacity = collapseResult.opacity;\n        }\n        \n        return { r, g, b, opacity };\n    }\n\n    /**\n     * Draw only effect for a cell (used in solid pattern mode)\n     * @private\n     */\n    _drawEffect(x, y, cols, rows) {\n        const effect = this.options.effect;\n        \n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, 0, effectOpacity);\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Draw effect circle if visible\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Draw a single cell\n     * @private\n     */\n    _drawCell(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Effect variables\n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (options.effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (options.effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Pattern color\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, effectOpacity);\n            opacity = collapseResult.opacity;\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Skip rendering if both opacities are 0 (performance optimization)\n        if (opacity <= 0 && effectOpacity <= 0) {\n            return;\n        }\n        \n        // Draw base pattern\n        this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;\n        if (this.options.solidPattern) {\n            // Solid mode: fill entire cell without gaps (add 0.5px overlap to prevent gaps)\n            const px = Math.floor(x * this._gridSize);\n            const py = Math.floor(y * this._gridSize);\n            this.ctx.fillRect(px, py, Math.ceil(this._gridSize) + 1, Math.ceil(this._gridSize) + 1);\n        } else {\n            // Circle mode\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        \n        // Draw effect on top (always circles)\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Calculate wave effect\n     * @private\n     */\n    _calculateWaveEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        // Combined sparkle mode - sparkles that get boosted by wave\n        if (effect.combineSparkle && centerFade > 0) {\n            // Calculate wave proximity (0-1, 1 = wave is here)\n            const cellDiag = x + y;\n            const distFromLine = Math.abs(cellDiag - this._diagPos);\n            // Narrower wave effect zone for more dramatic boost\n            const waveProximity = Math.max(0, 1 - distFromLine / effect.width);\n            // Sharper falloff - wave effect drops quickly\n            const smoothWaveProximity = Math.pow(waveProximity, 0.5);\n            \n            // Calculate sparkle\n            const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n            const rand1 = hash1 - Math.floor(hash1);\n            const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n            const rand2 = hash2 - Math.floor(hash2);\n            \n            // Use twinkle density for sparkle distribution\n            const sparkleThreshold = 1 - effect.density / 100 * 0.9;\n            \n            if (rand1 > sparkleThreshold) {\n                const phase = rand2 * Math.PI * 2;\n                const sparkleSpeed = 0.1 + (effect.twinkleSpeed / 100) * 0.4;\n                const twinkleWave = Math.sin(_twinkleTime * sparkleSpeed + phase);\n                const sparkle = Math.max(0, twinkleWave);\n                \n                // Base opacity is limited, wave boosts it to full\n                const baseOpacity = effect.sparkleBaseOpacity / 100;\n                const maxBoost = 1 - baseOpacity;\n                const finalOpacity = baseOpacity + (maxBoost * smoothWaveProximity);\n                \n                opacity = sparkle * finalOpacity * centerFade;\n                \n                if (effect.aurora) {\n                    const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                    const colorBlend = colorRand - Math.floor(colorRand);\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            }\n            \n            return { color, opacity };\n        }\n        \n        const cellDiag = x + y;\n        const distFromLine = Math.abs(cellDiag - this._diagPos);\n        \n        if (distFromLine < effect.width && this._sparkleMap[`${x},${y}`] !== undefined) {\n            const normalizedDist = distFromLine / effect.width;\n            const sparkle = Math.cos(normalizedDist * Math.PI * 0.5) * effect.intensity;\n            \n            // Cylinder effect\n            const fullDiagonalLength = Math.min(cols, rows);\n            const diagStartX = Math.max(0, Math.floor(this._diagPos) - (rows - 1));\n            const diagEndX = Math.min(cols - 1, Math.floor(this._diagPos));\n            const currentLineLength = Math.max(1, diagEndX - diagStartX + 1);\n            \n            let cylinderFade = 1;\n            if (currentLineLength >= fullDiagonalLength && currentLineLength > 1) {\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                cylinderFade = 0.3 + 0.7 * Math.sin(clampedPos * Math.PI);\n            } else if (currentLineLength > 1) {\n                const completeness = currentLineLength / fullDiagonalLength;\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                const baseFade = Math.sin(clampedPos * Math.PI);\n                cylinderFade = Math.max(0.3, 1 - (1 - baseFade) * completeness * 0.7);\n            }\n            \n            opacity = sparkle * this._sparkleMap[`${x},${y}`] * Math.max(0, cylinderFade) * centerFade;\n            \n            // Color\n            if (effect.aurora) {\n                const colorNoise = noise.noise2D(x * options.colorScale * 2 + randomOffset, y * options.colorScale * 2 + _animTime + randomOffset);\n                const colorBlend = (colorNoise + 1) / 2;\n                color = [\n                    Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                    Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                    Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                ];\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Calculate twinkle effect\n     * @private\n     */\n    _calculateTwinkleEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        if (centerFade > 0) {\n            // Combined mode - sparkles that get boosted by passing waves\n            if (effect.combined) {\n                // Calculate wave intensity first\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                const waveIntensity = Math.pow(smoothWave, 0.5); // Smoother wave\n                \n                // Calculate sparkle\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue * 2 + phase);\n                    const sparkle = Math.max(0, twinkleWave);\n                    \n                    // Base opacity is limited, wave boosts it to full\n                    const baseOpacity = effect.baseOpacity / 100;\n                    const maxBoost = 1 - baseOpacity;\n                    const finalOpacity = baseOpacity + (maxBoost * waveIntensity);\n                    \n                    opacity = sparkle * finalOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n            // Wave mode - flowing waves that boost opacity to 100%\n            else if (effect.mode === 'wave') {\n                // Create smooth, wide flowing light bands\n                // Size controls the width of the bands\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                // Slow, smooth primary wave - creates wide bands\n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                \n                // Very slow secondary wave for organic variation\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                \n                // Third wave for extra organic feel\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                // Combine waves smoothly\n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                \n                // Smooth sine-based intensity (no harsh ridges)\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                \n                // Apply density as band width control\n                const densityFactor = 0.3 + this._twinkleThreshold * 0.7;\n                const intensity = Math.pow(smoothWave, 1 / densityFactor);\n                \n                // Smooth the final output\n                opacity = intensity * effect.intensity * centerFade;\n                \n                // Aurora colors for wave mode\n                if (effect.aurora && opacity > 0) {\n                    const colorWave = noise.noise2D(\n                        x * baseScale * 0.3 + _twinkleTime * waveSpeed * 0.1 + randomOffset,\n                        y * baseScale * 0.3 + randomOffset\n                    );\n                    const colorBlend = (colorWave + 1) / 2;\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            } else {\n                // Sparkle mode - original random twinkling\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                \n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue + phase);\n                    const baseBrightness = Math.max(0, twinkleWave);\n                    \n                    const groupWave = noise.noise2D(\n                        x * this._twinkleScaleValue + _twinkleTime * 0.2 + randomOffset,\n                        y * this._twinkleScaleValue + randomOffset\n                    );\n                    const maxOpacity = 0.2 + (groupWave + 1) / 2 * 0.8;\n                    \n                    opacity = baseBrightness * maxOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Apply collapse effect\n     * @private\n     */\n    _applyCollapse(x, y, cols, rows, opacity, effectOpacity) {\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const normalizedDist = distFromCenter / maxRadius;\n        \n        const collapseAt = 1 - normalizedDist;\n        \n        if (this._collapseProgress > collapseAt + this.options.collapseWaveWidth) {\n            opacity = 0;\n            effectOpacity = 0;\n        } else if (this._collapseProgress > collapseAt) {\n            const t = 1 - (this._collapseProgress - collapseAt) / this.options.collapseWaveWidth;\n            const smoothFade = t * t * (3 - 2 * t);\n            opacity *= smoothFade;\n            effectOpacity *= smoothFade;\n        }\n        \n        return { opacity, effectOpacity };\n    }\n\n    /**\n     * Update collapse animation\n     * @private\n     */\n    _updateCollapse() {\n        const collapseEnd = 1 + this.options.collapseWaveWidth;\n        const opts = this.options;\n        \n        if (this._isCollapsing && this._collapseProgress < collapseEnd) {\n            // Use duration-based speed if hideDuration is set\n            const speed = this._hideSpeed || opts.collapseSpeed;\n            this._collapseProgress += speed;\n            \n            // Update canvas opacity if fadeOpacity is enabled\n            if (opts.fadeOpacity) {\n                const progress = Math.min(this._collapseProgress / collapseEnd, 1);\n                this.canvas.style.opacity = 1 - progress;\n            }\n            \n            // Update CSS classes\n            if (opts.hidingClass && !this.canvas.classList.contains(opts.hidingClass)) {\n                this.canvas.classList.remove(opts.revealingClass, opts.visibleClass);\n                this.canvas.classList.add(opts.hidingClass);\n            }\n            \n            if (this._collapseProgress >= collapseEnd) {\n                this._collapseProgress = collapseEnd;\n                this._hideSpeed = null;\n                \n                // Set final opacity\n                if (opts.fadeOpacity) {\n                    this.canvas.style.opacity = 0;\n                }\n                \n                // Update CSS classes\n                if (opts.hidingClass) this.canvas.classList.remove(opts.hidingClass);\n                if (opts.hiddenClass) this.canvas.classList.add(opts.hiddenClass);\n                \n                if (opts.onHide) {\n                    opts.onHide();\n                }\n            }\n        } else if (!this._isCollapsing && this._collapseProgress > 0) {\n            // Use duration-based speed if showDuration is set\n            const speed = this._showSpeed || opts.collapseSpeed;\n            this._collapseProgress -= speed;\n            \n            // Update canvas opacity if fadeOpacity is enabled\n            if (opts.fadeOpacity) {\n                const progress = Math.max(this._collapseProgress / collapseEnd, 0);\n                this.canvas.style.opacity = 1 - progress;\n            }\n            \n            // Update CSS classes\n            if (opts.revealingClass && !this.canvas.classList.contains(opts.revealingClass)) {\n                this.canvas.classList.remove(opts.hidingClass, opts.hiddenClass);\n                this.canvas.classList.add(opts.revealingClass);\n            }\n            \n            if (this._collapseProgress <= 0) {\n                this._collapseProgress = 0;\n                this._showSpeed = null;\n                \n                // Set final opacity\n                if (opts.fadeOpacity) {\n                    this.canvas.style.opacity = 1;\n                }\n                \n                // Update CSS classes\n                if (opts.revealingClass) this.canvas.classList.remove(opts.revealingClass);\n                if (opts.visibleClass) this.canvas.classList.add(opts.visibleClass);\n                \n                if (opts.onShow) {\n                    opts.onShow();\n                }\n            }\n        }\n    }\n\n    // ==================== PUBLIC API ====================\n\n    /**\n     * Start the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    start() {\n        if (!this._isRunning) {\n            this._isRunning = true;\n            this._lastFrameTime = performance.now();\n            this._animationId = requestAnimationFrame(this._draw);\n        }\n        return this;\n    }\n\n    /**\n     * Stop the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    stop() {\n        this._isRunning = false;\n        if (this._animationId) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = null;\n        }\n        return this;\n    }\n\n    /**\n     * Manually trigger a resize (useful when container size changes)\n     * @param {number} [width] - Optional new width\n     * @param {number} [height] - Optional new height\n     * @returns {Borealis} this instance for chaining\n     */\n    resize(width, height) {\n        if (width !== undefined) {\n            this.options.width = width;\n        }\n        if (height !== undefined) {\n            this.options.height = height;\n        }\n        this._resize();\n        return this;\n    }\n\n    /**\n     * Force a single frame redraw (useful when animation is stopped)\n     * @returns {Borealis} this instance for chaining\n     */\n    redraw() {\n        const time = performance.now();\n        const wasRunning = this._isRunning;\n        this._isRunning = true;\n        this._lastFrameTime = time - 16; // Simulate ~60fps frame\n        \n        // Draw single frame without requesting next\n        const delta = 16;\n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        if (this.options.solidPattern) {\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        this._isRunning = wasRunning;\n        return this;\n    }\n\n    /**\n     * Show the pattern (expand from center)\n     * @param {number|Function} [durationOrCallback] - Duration in ms or callback function\n     * @param {Function} [callback] - Called when animation completes (if first param is duration)\n     * @returns {Borealis} this instance for chaining\n     */\n    show(durationOrCallback, callback) {\n        let duration = null;\n        let cb = null;\n        \n        if (typeof durationOrCallback === 'function') {\n            cb = durationOrCallback;\n        } else if (typeof durationOrCallback === 'number') {\n            duration = durationOrCallback;\n            cb = callback;\n        }\n        \n        // Calculate speed from duration\n        if (duration !== null) {\n            const collapseEnd = 1 + this.options.collapseWaveWidth;\n            const framesNeeded = duration / 16.67; // ~60fps\n            this._showSpeed = collapseEnd / framesNeeded;\n        } else if (this.options.showDuration) {\n            const collapseEnd = 1 + this.options.collapseWaveWidth;\n            const framesNeeded = this.options.showDuration / 16.67;\n            this._showSpeed = collapseEnd / framesNeeded;\n        }\n        \n        this._isCollapsing = false;\n        if (cb) {\n            const originalCallback = this.options.onShow;\n            this.options.onShow = () => {\n                cb();\n                this.options.onShow = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Hide the pattern (collapse to center)\n     * @param {number|Function} [durationOrCallback] - Duration in ms or callback function\n     * @param {Function} [callback] - Called when animation completes (if first param is duration)\n     * @returns {Borealis} this instance for chaining\n     */\n    hide(durationOrCallback, callback) {\n        let duration = null;\n        let cb = null;\n        \n        if (typeof durationOrCallback === 'function') {\n            cb = durationOrCallback;\n        } else if (typeof durationOrCallback === 'number') {\n            duration = durationOrCallback;\n            cb = callback;\n        }\n        \n        // Calculate speed from duration\n        if (duration !== null) {\n            const collapseEnd = 1 + this.options.collapseWaveWidth;\n            const framesNeeded = duration / 16.67; // ~60fps\n            this._hideSpeed = collapseEnd / framesNeeded;\n        } else if (this.options.hideDuration) {\n            const collapseEnd = 1 + this.options.collapseWaveWidth;\n            const framesNeeded = this.options.hideDuration / 16.67;\n            this._hideSpeed = collapseEnd / framesNeeded;\n        }\n        \n        this._isCollapsing = true;\n        if (cb) {\n            const originalCallback = this.options.onHide;\n            this.options.onHide = () => {\n                cb();\n                this.options.onHide = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Toggle between show and hide\n     * @param {number|Function} [durationOrCallback] - Duration in ms or callback function\n     * @param {Function} [callback] - Called when animation completes (if first param is duration)\n     * @returns {Borealis} this instance for chaining\n     */\n    toggle(durationOrCallback, callback) {\n        if (this._isCollapsing) {\n            return this.show(durationOrCallback, callback);\n        } else {\n            return this.hide(durationOrCallback, callback);\n        }\n    }\n\n    /**\n     * Check if currently visible (not collapsed)\n     * @returns {boolean}\n     */\n    isVisible() {\n        return !this._isCollapsing && this._collapseProgress === 0;\n    }\n\n    /**\n     * Check if currently hidden (fully collapsed)\n     * @returns {boolean}\n     */\n    isHidden() {\n        return this._isCollapsing && this._collapseProgress >= 1 + this.options.collapseWaveWidth;\n    }\n\n    /**\n     * Set a single option\n     * @param {string} key - Option key\n     * @param {*} value - Option value\n     * @returns {Borealis} this instance for chaining\n     */\n    setOption(key, value) {\n        // Handle effect as special case (use setEffect instead)\n        if (key === 'effect') {\n            if (typeof value === 'object') {\n                return this.setEffect(value.type, value);\n            }\n            return this;\n        }\n        \n        this.options[key] = value;\n        \n        // Handle special cases that need resize/recalculation\n        const needsResize = [\n            'density', 'dotSize', 'solidPattern', 'patternAurora', \n            'maxOpacity', 'minOpacity'\n        ];\n        \n        if (needsResize.includes(key)) {\n            this._updateDensity(this.options.density);\n            this._resize();\n        }\n        \n        return this;\n    }\n\n    /**\n     * Set effect type and options\n     * @param {string} type - Effect type: 'none', 'wave', or 'twinkle'\n     * @param {Object} [effectOptions] - Effect-specific options\n     * @returns {Borealis} this instance for chaining\n     */\n    setEffect(type, effectOptions = {}) {\n        // Update effect type\n        if (type) {\n            this.options.effect.type = type;\n        }\n        \n        // Merge effect options\n        Object.keys(effectOptions).forEach(key => {\n            if (key !== 'type') {\n                this.options.effect[key] = effectOptions[key];\n            }\n        });\n        \n        // Update internal computed values\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        this._resize();\n        \n        return this;\n    }\n\n    /**\n     * Get current effect configuration\n     * @returns {Object} Effect configuration with type and options\n     */\n    getEffect() {\n        return { ...this.options.effect };\n    }\n\n    /**\n     * Set multiple options at once\n     * @param {Object} options - Options object\n     * @returns {Borealis} this instance for chaining\n     */\n    setOptions(options) {\n        Object.keys(options).forEach(key => {\n            this.setOption(key, options[key]);\n        });\n        return this;\n    }\n\n    /**\n     * Get current options\n     * @returns {Object} Current options\n     */\n    getOptions() {\n        return { ...this.options };\n    }\n\n    /**\n     * Get a specific option value\n     * @param {string} key - Option key\n     * @returns {*} Option value\n     */\n    getOption(key) {\n        return this.options[key];\n    }\n\n    /**\n     * Destroy the instance and clean up\n     */\n    destroy() {\n        this.stop();\n        window.removeEventListener('resize', this._resize);\n        \n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n        \n        this.canvas = null;\n        this.ctx = null;\n        this.noise = null;\n    }\n}\n\nexport default Borealis;\n"],"names":["SimplexNoise","constructor","seed","Math","random","this","p","Uint8Array","i","j","perm","noise2D","x","y","F2","sqrt","G2","s","floor","t","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","grad","hash","h","u","v","n0","n1","n2","t0","t1","t2","Borealis","defaultOptions","container","document","body","width","height","fullscreen","zIndex","initiallyHidden","className","background","density","dotSize","solidPattern","densityMinCell","densityMaxCell","densityMinGap","densityMaxGap","patternScale","patternAurora","warpScale","warpAmount","animationSpeed","ridgePower","minOpacity","maxOpacity","waveFrequency","waveAmplitude","effect","type","aurora","deadzone","speed","chance","intensity","delayMin","delayMax","combineSparkle","sparkleBaseOpacity","mode","combined","baseOpacity","twinkleSpeed","size","auroraColor1","auroraColor2","colorScale","collapseSpeed","collapseWaveWidth","showDuration","hideDuration","fadeOpacity","revealingClass","visibleClass","hidingClass","hiddenClass","autoStart","onShow","onHide","options","defaultEffect","userEffect","_init","canvas","createElement","style","cssText","insertBefore","firstChild","window","getComputedStyle","position","appendChild","ctx","getContext","noise","randomOffset","_cellSize","_gap","_gridSize","_sparkleMap","_animTime","_twinkleTime","_lastFrameTime","_sparkleWaiting","_sparkleWaitUntil","_diagPos","_isCollapsing","_collapseProgress","_isRunning","_animationId","_showSpeed","_hideSpeed","classList","add","opacity","_twinkleThreshold","_twinkleSpeedValue","_twinkleScaleValue","_deadzoneValue","_updateDensity","_updateTwinkleSettings","_updateDeadzone","_draw","bind","_resize","addEventListener","start","value","baseCell","sizeMultiplier","_generateSparkles","cols","rows","innerWidth","innerHeight","clientWidth","clientHeight","ceil","_offscreenCanvas","_offscreenCtx","time","delta","maxDiag","delay","clearRect","offCtx","imageData","createImageData","data","cellData","_calculateCellData","idx","r","g","b","round","putImageData","imageSmoothingEnabled","imageSmoothingQuality","drawImage","_drawEffect","_drawCell","_updateCollapse","requestAnimationFrame","wave1","sin","wave2","cos","warpX","warpY","noiseVal","ridge","abs","rawOpacity","pow","colorBlend","_applyCollapse","effectColor","effectOpacity","result","_calculateWaveEffect","color","_calculateTwinkleEffect","fillStyle","beginPath","arc","PI","fill","collapseResult","px","py","fillRect","centerX","centerY","distFromCenter","maxRadius","fadeZone","centerFade","cellDiag","distFromLine","waveProximity","max","smoothWaveProximity","hash1","rand1","hash2","rand2","phase","sparkleSpeed","twinkleWave","sparkle","colorRand","undefined","normalizedDist","fullDiagonalLength","min","diagStartX","diagEndX","currentLineLength","cylinderFade","posAlongLine","clampedPos","completeness","baseFade","baseScale","waveSpeed","smoothWave","waveIntensity","densityFactor","collapseAt","smoothFade","collapseEnd","opts","progress","contains","remove","performance","now","stop","cancelAnimationFrame","resize","redraw","wasRunning","show","durationOrCallback","callback","duration","cb","framesNeeded","originalCallback","hide","toggle","isVisible","isHidden","setOption","key","setEffect","includes","effectOptions","Object","keys","forEach","getEffect","setOptions","getOptions","getOption","destroy","removeEventListener","parentNode","removeChild"],"mappings":"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"}