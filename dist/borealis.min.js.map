{"version":3,"file":"borealis.min.js","sources":["../src/borealis.js"],"sourcesContent":["/**\n * Borealis - Interactive Animated Background\n * A canvas-based particle animation system with noise patterns and effects\n * \n * @author Borealis\n * @version 1.0.0\n */\n\nclass SimplexNoise {\n    constructor(seed = Math.random()) {\n        this.p = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) this.p[i] = i;\n        \n        for (let i = 255; i > 0; i--) {\n            seed = (seed * 16807) % 2147483647;\n            const j = seed % (i + 1);\n            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n        }\n        \n        this.perm = new Uint8Array(512);\n        for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];\n    }\n\n    noise2D(x, y) {\n        const F2 = 0.5 * (Math.sqrt(3) - 1);\n        const G2 = (3 - Math.sqrt(3)) / 6;\n        \n        const s = (x + y) * F2;\n        const i = Math.floor(x + s);\n        const j = Math.floor(y + s);\n        \n        const t = (i + j) * G2;\n        const X0 = i - t;\n        const Y0 = j - t;\n        const x0 = x - X0;\n        const y0 = y - Y0;\n        \n        const i1 = x0 > y0 ? 1 : 0;\n        const j1 = x0 > y0 ? 0 : 1;\n        \n        const x1 = x0 - i1 + G2;\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1 + 2 * G2;\n        const y2 = y0 - 1 + 2 * G2;\n        \n        const ii = i & 255;\n        const jj = j & 255;\n        \n        const grad = (hash, x, y) => {\n            const h = hash & 7;\n            const u = h < 4 ? x : y;\n            const v = h < 4 ? y : x;\n            return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);\n        };\n        \n        let n0 = 0, n1 = 0, n2 = 0;\n        \n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 >= 0) {\n            t0 *= t0;\n            n0 = t0 * t0 * grad(this.perm[ii + this.perm[jj]], x0, y0);\n        }\n        \n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 >= 0) {\n            t1 *= t1;\n            n1 = t1 * t1 * grad(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1);\n        }\n        \n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 >= 0) {\n            t2 *= t2;\n            n2 = t2 * t2 * grad(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2);\n        }\n        \n        return 70 * (n0 + n1 + n2);\n    }\n}\n\nclass Borealis {\n    /**\n     * Default options for Borealis\n     */\n    static get defaultOptions() {\n        return {\n            // Container & Size\n            container: document.body,\n            width: null,                    // Canvas width (null = auto from container/window)\n            height: null,                   // Canvas height (null = auto from container/window)\n            fullscreen: true,               // If true, uses fixed positioning to cover viewport\n            zIndex: 0,                      // Canvas z-index (can be any integer)\n            initiallyHidden: false,         // If true, starts collapsed/hidden\n            className: null,                // Custom class name for canvas\n            background: null,               // Canvas background (color, gradient, etc.)\n            \n            // Grid settings\n            density: 50,                    // Grid density (10-100)\n            dotSize: 5,                     // Dot size (0-10, 0=smallest)\n            solidPattern: false,            // Solid pattern without gaps/circles\n            densityMinCell: 2,              // Cell size at max density\n            densityMaxCell: 8,              // Cell size at min density\n            densityMinGap: 1,               // Gap at max density\n            densityMaxGap: 4,               // Gap at min density\n            \n            // Pattern settings\n            patternScale: 0.001,            // Noise scale (smaller = larger patterns)\n            patternAurora: false,           // Use aurora colors for pattern\n            warpScale: 0.5,                 // Domain warp frequency multiplier\n            warpAmount: 20,                 // Domain warp intensity\n            animationSpeed: 0.00002,        // Animation speed multiplier\n            ridgePower: 2,                  // Ridge sharpness (higher = sharper lines)\n            minOpacity: 0,                  // Minimum opacity (0-1)\n            maxOpacity: 1,                  // Maximum opacity (0-1)\n            waveFrequency: 3,               // Wave oscillation frequency\n            waveAmplitude: 0.5,             // Wave intensity (0-1)\n            \n            // Effect settings (unified structure)\n            effect: {\n                type: 'wave',               // 'none', 'wave', 'twinkle'\n                aurora: false,              // Use aurora colors for effect\n                deadzone: 20,               // Center dead zone size (0-100)\n                // Wave-specific options\n                speed: 0.0008,              // Diagonal line speed\n                width: 120,                 // Width of the wave band\n                chance: 0.08,               // Chance of a cell sparkling (0-1)\n                intensity: 1,               // Max brightness\n                delayMin: 1000,             // Min delay between sweeps (ms)\n                delayMax: 3000,             // Max delay between sweeps (ms)\n                combineSparkle: false,      // Add sparkles that get boosted by wave\n                sparkleBaseOpacity: 0,      // Sparkle base opacity when wave not passing (0-100)\n                // Twinkle-specific options\n                mode: 'sparkle',            // 'sparkle' (random) or 'wave' (flowing waves)\n                combined: false,            // Combine sparkle with wave (sparkles boosted by wave)\n                baseOpacity: 30,            // Base opacity when wave is not passing (0-100)\n                twinkleSpeed: 50,           // Twinkle animation speed (10-100)\n                size: 50,                   // Pattern size (10-100)\n                density: 50,                // Star density (0-100)\n            },\n            \n            // Aurora colors\n            auroraColor1: [0, 255, 128],    // Cyan-green\n            auroraColor2: [148, 0, 211],    // Violet\n            colorScale: 0.003,              // Color variation scale\n            \n            // Collapse settings\n            collapseSpeed: 0.1,             // Collapse animation speed\n            collapseWaveWidth: 0.4,         // Width of the collapse transition\n            \n            // Animation\n            autoStart: true,                // Start animation automatically\n            \n            // Callbacks\n            onShow: null,                   // Called when show animation completes\n            onHide: null,                   // Called when hide animation completes\n        };\n    }\n\n    /**\n     * Create a new Borealis instance\n     * @param {Object} options - Configuration options\n     */\n    constructor(options = {}) {\n        // Deep merge for effect object\n        const defaultEffect = Borealis.defaultOptions.effect;\n        const userEffect = options.effect || {};\n        \n        this.options = { \n            ...Borealis.defaultOptions, \n            ...options,\n            effect: { ...defaultEffect, ...userEffect }\n        };\n        this._init();\n    }\n\n    /**\n     * Initialize the Borealis instance\n     * @private\n     */\n    _init() {\n        // Create canvas\n        this.canvas = document.createElement('canvas');\n        \n        // Set custom class name if provided\n        if (this.options.className) {\n            this.canvas.className = this.options.className;\n        }\n        \n        // Set canvas styles based on mode\n        const zIndex = this.options.zIndex;\n        const background = this.options.background ? `background: ${this.options.background};` : '';\n        if (this.options.fullscreen) {\n            this.canvas.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n                ${background}\n            `;\n        } else {\n            this.canvas.style.cssText = `\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                pointer-events: none;\n                z-index: ${zIndex};\n                ${background}\n            `;\n        }\n        \n        // Add to container\n        const container = this.options.container;\n        if (container === document.body && this.options.fullscreen) {\n            document.body.insertBefore(this.canvas, document.body.firstChild);\n        } else {\n            // Ensure container has position for absolute positioning\n            const containerStyle = window.getComputedStyle(container);\n            if (containerStyle.position === 'static') {\n                container.style.position = 'relative';\n            }\n            container.appendChild(this.canvas);\n        }\n        \n        this.ctx = this.canvas.getContext('2d');\n        this.noise = new SimplexNoise(Math.random() * 10000);\n        this.randomOffset = Math.random() * 1000;\n        \n        // Internal state\n        this._cellSize = 4;\n        this._gap = 2;\n        this._gridSize = 6;\n        this._sparkleMap = {};\n        this._animTime = 0;\n        this._twinkleTime = 0;\n        this._lastFrameTime = 0;\n        this._sparkleWaiting = false;\n        this._sparkleWaitUntil = 0;\n        this._diagPos = 0;\n        this._isCollapsing = this.options.initiallyHidden;  // Stay collapsed until manual show() call\n        this._collapseProgress = this.options.initiallyHidden ? 1 + this.options.collapseWaveWidth : 0;  // Start fully hidden if initiallyHidden is true\n        this._isRunning = false;\n        this._animationId = null;\n        \n        // Computed twinkle values\n        this._twinkleThreshold = 0.8;\n        this._twinkleSpeedValue = 3;\n        this._twinkleScaleValue = 0.01;\n        this._deadzoneValue = 0.2;\n        \n        // Apply initial options\n        this._updateDensity(this.options.density);\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        \n        // Bind methods\n        this._draw = this._draw.bind(this);\n        this._resize = this._resize.bind(this);\n        \n        // Setup event listeners\n        window.addEventListener('resize', this._resize);\n        \n        // Initial resize\n        this._resize();\n        \n        // Auto start\n        if (this.options.autoStart) {\n            this.start();\n        }\n    }\n\n    /**\n     * Update density settings\n     * @private\n     */\n    _updateDensity(value) {\n        const t = (100 - value) / 90;\n        const baseCell = this.options.densityMinCell + t * (this.options.densityMaxCell - this.options.densityMinCell);\n        // Apply dotSize multiplier (0 = 0.3x, 5 = 1x, 10 = 2x)\n        const sizeMultiplier = 0.3 + (this.options.dotSize / 10) * 1.7;\n        this._cellSize = baseCell * sizeMultiplier;\n        this._gap = this.options.densityMinGap + t * (this.options.densityMaxGap - this.options.densityMinGap);\n        this._gridSize = this._cellSize + this._gap;\n    }\n\n    /**\n     * Update twinkle settings from options\n     * @private\n     */\n    _updateTwinkleSettings() {\n        const effect = this.options.effect;\n        // Speed: 10-100 maps to 1-6\n        this._twinkleSpeedValue = 1 + (effect.twinkleSpeed - 10) / 90 * 5;\n        // Size: 10-100 maps to 0.5-0.001 (inverted, much wider range)\n        this._twinkleScaleValue = 0.5 - (effect.size - 10) / 90 * 0.499;\n        // Density: 0-100 maps to threshold 1.0-0.1\n        this._twinkleThreshold = 1 - effect.density / 100 * 0.9;\n    }\n\n    /**\n     * Update deadzone setting (applies to all effects)\n     * @private\n     */\n    _updateDeadzone() {\n        // Deadzone: 0-100 maps to 0-1 (percentage of diagonal distance from center to corner)\n        this._deadzoneValue = this.options.effect.deadzone / 100;\n    }\n\n    /**\n     * Generate sparkle map\n     * @private\n     */\n    _generateSparkles(cols, rows) {\n        this._sparkleMap = {};\n        for (let y = 0; y < rows; y++) {\n            for (let x = 0; x < cols; x++) {\n                if (Math.random() < this.options.effect.chance) {\n                    this._sparkleMap[`${x},${y}`] = Math.random();\n                }\n            }\n        }\n    }\n\n    /**\n     * Resize handler\n     * @private\n     */\n    _resize() {\n        // Determine dimensions\n        let width, height;\n        \n        if (this.options.width !== null && this.options.height !== null) {\n            // Use explicit dimensions\n            width = this.options.width;\n            height = this.options.height;\n        } else if (this.options.fullscreen) {\n            // Use window dimensions\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            // Use container dimensions\n            const container = this.options.container;\n            width = this.options.width !== null ? this.options.width : container.clientWidth;\n            height = this.options.height !== null ? this.options.height : container.clientHeight;\n        }\n        \n        this.canvas.width = width;\n        this.canvas.height = height;\n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        this._generateSparkles(cols, rows);\n        // Clear offscreen canvas cache on resize\n        this._offscreenCanvas = null;\n        this._offscreenCtx = null;\n    }\n\n    /**\n     * Main draw loop\n     * @private\n     */\n    _draw(time) {\n        if (!this._isRunning) return;\n        \n        const delta = time - this._lastFrameTime;\n        \n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        // Handle wave timing\n        const effect = this.options.effect;\n        if (!this._sparkleWaiting) {\n            this._diagPos += delta * effect.speed * 100;\n            \n            const cols = Math.ceil(this.canvas.width / this._gridSize);\n            const rows = Math.ceil(this.canvas.height / this._gridSize);\n            const maxDiag = cols + rows;\n            \n            if (this._diagPos > maxDiag + effect.width) {\n                this._sparkleWaiting = true;\n                const delay = effect.delayMin + Math.random() * (effect.delayMax - effect.delayMin);\n                this._sparkleWaitUntil = time + delay;\n                this._generateSparkles(cols, rows);\n            }\n        } else {\n            if (time >= this._sparkleWaitUntil) {\n                this._sparkleWaiting = false;\n                this._diagPos = -effect.width;\n            }\n        }\n        \n        this._lastFrameTime = time;\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        // For solid pattern, use offscreen canvas for pixel-perfect base pattern\n        if (this.options.solidPattern) {\n            // Create or reuse offscreen canvas at grid resolution\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            // Draw only base pattern to ImageData (no effects)\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    \n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            \n            // Scale up to full canvas size with smooth interpolation\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            // Draw effects on top using regular canvas API (crisp circles)\n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        // Update collapse\n        this._updateCollapse();\n        \n        this._animationId = requestAnimationFrame(this._draw);\n    }\n\n    /**\n     * Calculate cell data for solid pattern (used for ImageData rendering)\n     * @private\n     */\n    _calculateCellData(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Pattern color (no effects in solid pattern base - effects drawn separately)\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse (only base pattern, no effect)\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, 0);\n            opacity = collapseResult.opacity;\n        }\n        \n        return { r, g, b, opacity };\n    }\n\n    /**\n     * Draw only effect for a cell (used in solid pattern mode)\n     * @private\n     */\n    _drawEffect(x, y, cols, rows) {\n        const effect = this.options.effect;\n        \n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, 0, effectOpacity);\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Draw effect circle if visible\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Draw a single cell\n     * @private\n     */\n    _drawCell(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        \n        // Oscillating wave effect\n        const wave1 = Math.sin(_animTime * options.waveFrequency + x * options.patternScale * 10) * options.waveAmplitude;\n        const wave2 = Math.cos(_animTime * options.waveFrequency * 0.7 + y * options.patternScale * 10) * options.waveAmplitude;\n        \n        // Domain warping\n        const warpX = noise.noise2D(x * options.patternScale * options.warpScale + wave1 + randomOffset, y * options.patternScale * options.warpScale + _animTime + randomOffset) * options.warpAmount;\n        const warpY = noise.noise2D(x * options.patternScale * options.warpScale + 100 + randomOffset, y * options.patternScale * options.warpScale + _animTime + wave2 + randomOffset) * options.warpAmount;\n        \n        const noiseVal = noise.noise2D(\n            (x + warpX) * options.patternScale + wave2 * 0.5 + randomOffset,\n            (y + warpY) * options.patternScale + wave1 * 0.5 + randomOffset\n        );\n        \n        // Ridge noise\n        const ridge = 1 - Math.abs(noiseVal);\n        const rawOpacity = Math.pow(ridge, options.ridgePower);\n        let opacity = options.minOpacity + rawOpacity * (options.maxOpacity - options.minOpacity);\n        \n        // Effect variables\n        let effectColor = [255, 255, 255];\n        let effectOpacity = 0;\n        \n        // Wave effect\n        if (options.effect.type === 'wave' && !this._sparkleWaiting) {\n            const result = this._calculateWaveEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Twinkle effect\n        if (options.effect.type === 'twinkle') {\n            const result = this._calculateTwinkleEffect(x, y, cols, rows);\n            effectColor = result.color;\n            effectOpacity = result.opacity;\n        }\n        \n        // Pattern color\n        let r, g, b;\n        if (options.patternAurora) {\n            const colorNoise = noise.noise2D(x * options.colorScale + randomOffset * 0.5, y * options.colorScale + _animTime * 0.5 + randomOffset * 0.5);\n            const colorBlend = (colorNoise + 1) / 2;\n            r = Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend);\n            g = Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend);\n            b = Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend);\n        } else {\n            r = g = b = 255;\n        }\n        \n        // Apply collapse\n        if (this._collapseProgress > 0) {\n            const collapseResult = this._applyCollapse(x, y, cols, rows, opacity, effectOpacity);\n            opacity = collapseResult.opacity;\n            effectOpacity = collapseResult.effectOpacity;\n        }\n        \n        // Skip rendering if both opacities are 0 (performance optimization)\n        if (opacity <= 0 && effectOpacity <= 0) {\n            return;\n        }\n        \n        // Draw base pattern\n        this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;\n        if (this.options.solidPattern) {\n            // Solid mode: fill entire cell without gaps (add 0.5px overlap to prevent gaps)\n            const px = Math.floor(x * this._gridSize);\n            const py = Math.floor(y * this._gridSize);\n            this.ctx.fillRect(px, py, Math.ceil(this._gridSize) + 1, Math.ceil(this._gridSize) + 1);\n        } else {\n            // Circle mode\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        \n        // Draw effect on top (always circles)\n        if (effectOpacity > 0) {\n            this.ctx.fillStyle = `rgba(${effectColor[0]}, ${effectColor[1]}, ${effectColor[2]}, ${effectOpacity})`;\n            this.ctx.beginPath();\n            this.ctx.arc(x * this._gridSize + this._cellSize / 2, y * this._gridSize + this._cellSize / 2, this._cellSize / 2, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n\n    /**\n     * Calculate wave effect\n     * @private\n     */\n    _calculateWaveEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _animTime, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        // Combined sparkle mode - sparkles that get boosted by wave\n        if (effect.combineSparkle && centerFade > 0) {\n            // Calculate wave proximity (0-1, 1 = wave is here)\n            const cellDiag = x + y;\n            const distFromLine = Math.abs(cellDiag - this._diagPos);\n            // Narrower wave effect zone for more dramatic boost\n            const waveProximity = Math.max(0, 1 - distFromLine / effect.width);\n            // Sharper falloff - wave effect drops quickly\n            const smoothWaveProximity = Math.pow(waveProximity, 0.5);\n            \n            // Calculate sparkle\n            const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n            const rand1 = hash1 - Math.floor(hash1);\n            const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n            const rand2 = hash2 - Math.floor(hash2);\n            \n            // Use twinkle density for sparkle distribution\n            const sparkleThreshold = 1 - effect.density / 100 * 0.9;\n            \n            if (rand1 > sparkleThreshold) {\n                const phase = rand2 * Math.PI * 2;\n                const sparkleSpeed = 0.1 + (effect.twinkleSpeed / 100) * 0.4;\n                const twinkleWave = Math.sin(_twinkleTime * sparkleSpeed + phase);\n                const sparkle = Math.max(0, twinkleWave);\n                \n                // Base opacity is limited, wave boosts it to full\n                const baseOpacity = effect.sparkleBaseOpacity / 100;\n                const maxBoost = 1 - baseOpacity;\n                const finalOpacity = baseOpacity + (maxBoost * smoothWaveProximity);\n                \n                opacity = sparkle * finalOpacity * centerFade;\n                \n                if (effect.aurora) {\n                    const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                    const colorBlend = colorRand - Math.floor(colorRand);\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            }\n            \n            return { color, opacity };\n        }\n        \n        const cellDiag = x + y;\n        const distFromLine = Math.abs(cellDiag - this._diagPos);\n        \n        if (distFromLine < effect.width && this._sparkleMap[`${x},${y}`] !== undefined) {\n            const normalizedDist = distFromLine / effect.width;\n            const sparkle = Math.cos(normalizedDist * Math.PI * 0.5) * effect.intensity;\n            \n            // Cylinder effect\n            const fullDiagonalLength = Math.min(cols, rows);\n            const diagStartX = Math.max(0, Math.floor(this._diagPos) - (rows - 1));\n            const diagEndX = Math.min(cols - 1, Math.floor(this._diagPos));\n            const currentLineLength = Math.max(1, diagEndX - diagStartX + 1);\n            \n            let cylinderFade = 1;\n            if (currentLineLength >= fullDiagonalLength && currentLineLength > 1) {\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                cylinderFade = 0.3 + 0.7 * Math.sin(clampedPos * Math.PI);\n            } else if (currentLineLength > 1) {\n                const completeness = currentLineLength / fullDiagonalLength;\n                const posAlongLine = (x - diagStartX) / (currentLineLength - 1);\n                const clampedPos = Math.max(0, Math.min(1, posAlongLine));\n                const baseFade = Math.sin(clampedPos * Math.PI);\n                cylinderFade = Math.max(0.3, 1 - (1 - baseFade) * completeness * 0.7);\n            }\n            \n            opacity = sparkle * this._sparkleMap[`${x},${y}`] * Math.max(0, cylinderFade) * centerFade;\n            \n            // Color\n            if (effect.aurora) {\n                const colorNoise = noise.noise2D(x * options.colorScale * 2 + randomOffset, y * options.colorScale * 2 + _animTime + randomOffset);\n                const colorBlend = (colorNoise + 1) / 2;\n                color = [\n                    Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                    Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                    Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                ];\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Calculate twinkle effect\n     * @private\n     */\n    _calculateTwinkleEffect(x, y, cols, rows) {\n        const { options, noise, randomOffset, _twinkleTime } = this;\n        const effect = options.effect;\n        let color = [255, 255, 255];\n        let opacity = 0;\n        \n        // Dead zone calculation (using diagonal distance to corner)\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2); // Distance from center to corner\n        const maxRadius = maxDist * this._deadzoneValue;\n        const fadeZone = maxRadius * 0.3;\n        \n        let centerFade = 1;\n        if (distFromCenter < maxRadius) {\n            centerFade = 0;\n        } else if (distFromCenter < maxRadius + fadeZone) {\n            const t = (distFromCenter - maxRadius) / fadeZone;\n            centerFade = t * t * (3 - 2 * t);\n        }\n        \n        if (centerFade > 0) {\n            // Combined mode - sparkles that get boosted by passing waves\n            if (effect.combined) {\n                // Calculate wave intensity first\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                const waveIntensity = Math.pow(smoothWave, 0.5); // Smoother wave\n                \n                // Calculate sparkle\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue * 2 + phase);\n                    const sparkle = Math.max(0, twinkleWave);\n                    \n                    // Base opacity is limited, wave boosts it to full\n                    const baseOpacity = effect.baseOpacity / 100;\n                    const maxBoost = 1 - baseOpacity;\n                    const finalOpacity = baseOpacity + (maxBoost * waveIntensity);\n                    \n                    opacity = sparkle * finalOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n            // Wave mode - flowing waves that boost opacity to 100%\n            else if (effect.mode === 'wave') {\n                // Create smooth, wide flowing light bands\n                // Size controls the width of the bands\n                const baseScale = 0.0005 + (1 - this._twinkleScaleValue) * 0.003;\n                const waveSpeed = this._twinkleSpeedValue * 0.15;\n                \n                // Slow, smooth primary wave - creates wide bands\n                const wave1 = noise.noise2D(\n                    x * baseScale + _twinkleTime * waveSpeed,\n                    y * baseScale + _twinkleTime * waveSpeed * 0.5 + randomOffset\n                );\n                \n                // Very slow secondary wave for organic variation\n                const wave2 = noise.noise2D(\n                    x * baseScale * 0.5 + _twinkleTime * waveSpeed * 0.3 + 50,\n                    y * baseScale * 0.7 - _twinkleTime * waveSpeed * 0.2 + randomOffset + 50\n                );\n                \n                // Third wave for extra organic feel\n                const wave3 = noise.noise2D(\n                    (x + y * 0.5) * baseScale * 0.8 + _twinkleTime * waveSpeed * 0.4,\n                    (y - x * 0.3) * baseScale * 0.8 + randomOffset + 100\n                );\n                \n                // Combine waves smoothly\n                const combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);\n                \n                // Smooth sine-based intensity (no harsh ridges)\n                const smoothWave = (Math.sin(combined * Math.PI * 2) + 1) / 2;\n                \n                // Apply density as band width control\n                const densityFactor = 0.3 + this._twinkleThreshold * 0.7;\n                const intensity = Math.pow(smoothWave, 1 / densityFactor);\n                \n                // Smooth the final output\n                opacity = intensity * effect.intensity * centerFade;\n                \n                // Aurora colors for wave mode\n                if (effect.aurora && opacity > 0) {\n                    const colorWave = noise.noise2D(\n                        x * baseScale * 0.3 + _twinkleTime * waveSpeed * 0.1 + randomOffset,\n                        y * baseScale * 0.3 + randomOffset\n                    );\n                    const colorBlend = (colorWave + 1) / 2;\n                    color = [\n                        Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                        Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                        Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                    ];\n                }\n            } else {\n                // Sparkle mode - original random twinkling\n                const hash1 = Math.sin(x * 12.9898 + y * 78.233 + randomOffset) * 43758.5453;\n                const rand1 = hash1 - Math.floor(hash1);\n                \n                const hash2 = Math.sin(x * 93.9898 + y * 67.345 + randomOffset * 2) * 23421.6312;\n                const rand2 = hash2 - Math.floor(hash2);\n                \n                if (rand1 > this._twinkleThreshold) {\n                    const phase = rand2 * Math.PI * 2;\n                    const twinkleWave = Math.sin(_twinkleTime * this._twinkleSpeedValue + phase);\n                    const baseBrightness = Math.max(0, twinkleWave);\n                    \n                    const groupWave = noise.noise2D(\n                        x * this._twinkleScaleValue + _twinkleTime * 0.2 + randomOffset,\n                        y * this._twinkleScaleValue + randomOffset\n                    );\n                    const maxOpacity = 0.2 + (groupWave + 1) / 2 * 0.8;\n                    \n                    opacity = baseBrightness * maxOpacity * effect.intensity * centerFade;\n                    \n                    if (effect.aurora) {\n                        const colorRand = Math.sin(x * 45.123 + y * 89.456 + randomOffset) * 12345.6789;\n                        const colorBlend = colorRand - Math.floor(colorRand);\n                        color = [\n                            Math.round(options.auroraColor1[0] + (options.auroraColor2[0] - options.auroraColor1[0]) * colorBlend),\n                            Math.round(options.auroraColor1[1] + (options.auroraColor2[1] - options.auroraColor1[1]) * colorBlend),\n                            Math.round(options.auroraColor1[2] + (options.auroraColor2[2] - options.auroraColor1[2]) * colorBlend)\n                        ];\n                    }\n                }\n            }\n        }\n        \n        return { color, opacity };\n    }\n\n    /**\n     * Apply collapse effect\n     * @private\n     */\n    _applyCollapse(x, y, cols, rows, opacity, effectOpacity) {\n        const centerX = cols / 2;\n        const centerY = rows / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);\n        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n        const normalizedDist = distFromCenter / maxRadius;\n        \n        const collapseAt = 1 - normalizedDist;\n        \n        if (this._collapseProgress > collapseAt + this.options.collapseWaveWidth) {\n            opacity = 0;\n            effectOpacity = 0;\n        } else if (this._collapseProgress > collapseAt) {\n            const t = 1 - (this._collapseProgress - collapseAt) / this.options.collapseWaveWidth;\n            const smoothFade = t * t * (3 - 2 * t);\n            opacity *= smoothFade;\n            effectOpacity *= smoothFade;\n        }\n        \n        return { opacity, effectOpacity };\n    }\n\n    /**\n     * Update collapse animation\n     * @private\n     */\n    _updateCollapse() {\n        const collapseEnd = 1 + this.options.collapseWaveWidth;\n        \n        if (this._isCollapsing && this._collapseProgress < collapseEnd) {\n            this._collapseProgress += this.options.collapseSpeed;\n            if (this._collapseProgress >= collapseEnd) {\n                this._collapseProgress = collapseEnd;\n                if (this.options.onHide) {\n                    this.options.onHide();\n                }\n            }\n        } else if (!this._isCollapsing && this._collapseProgress > 0) {\n            this._collapseProgress -= this.options.collapseSpeed;\n            if (this._collapseProgress <= 0) {\n                this._collapseProgress = 0;\n                if (this.options.onShow) {\n                    this.options.onShow();\n                }\n            }\n        }\n    }\n\n    // ==================== PUBLIC API ====================\n\n    /**\n     * Start the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    start() {\n        if (!this._isRunning) {\n            this._isRunning = true;\n            this._lastFrameTime = performance.now();\n            this._animationId = requestAnimationFrame(this._draw);\n        }\n        return this;\n    }\n\n    /**\n     * Stop the animation\n     * @returns {Borealis} this instance for chaining\n     */\n    stop() {\n        this._isRunning = false;\n        if (this._animationId) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = null;\n        }\n        return this;\n    }\n\n    /**\n     * Manually trigger a resize (useful when container size changes)\n     * @param {number} [width] - Optional new width\n     * @param {number} [height] - Optional new height\n     * @returns {Borealis} this instance for chaining\n     */\n    resize(width, height) {\n        if (width !== undefined) {\n            this.options.width = width;\n        }\n        if (height !== undefined) {\n            this.options.height = height;\n        }\n        this._resize();\n        return this;\n    }\n\n    /**\n     * Force a single frame redraw (useful when animation is stopped)\n     * @returns {Borealis} this instance for chaining\n     */\n    redraw() {\n        const time = performance.now();\n        const wasRunning = this._isRunning;\n        this._isRunning = true;\n        this._lastFrameTime = time - 16; // Simulate ~60fps frame\n        \n        // Draw single frame without requesting next\n        const delta = 16;\n        this._animTime += delta * this.options.animationSpeed;\n        this._twinkleTime += delta * 0.001;\n        \n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        const cols = Math.ceil(this.canvas.width / this._gridSize);\n        const rows = Math.ceil(this.canvas.height / this._gridSize);\n        \n        if (this.options.solidPattern) {\n            if (!this._offscreenCanvas || this._offscreenCanvas.width !== cols || this._offscreenCanvas.height !== rows) {\n                this._offscreenCanvas = document.createElement('canvas');\n                this._offscreenCanvas.width = cols;\n                this._offscreenCanvas.height = rows;\n                this._offscreenCtx = this._offscreenCanvas.getContext('2d');\n            }\n            \n            const offCtx = this._offscreenCtx;\n            const imageData = offCtx.createImageData(cols, rows);\n            const data = imageData.data;\n            \n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const cellData = this._calculateCellData(x, y, cols, rows);\n                    const idx = (y * cols + x) * 4;\n                    data[idx] = cellData.r;\n                    data[idx + 1] = cellData.g;\n                    data[idx + 2] = cellData.b;\n                    data[idx + 3] = Math.round(cellData.opacity * 255);\n                }\n            }\n            \n            offCtx.putImageData(imageData, 0, 0);\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.ctx.drawImage(this._offscreenCanvas, 0, 0, this.canvas.width, this.canvas.height);\n            \n            if (this.options.effect.type !== 'none') {\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        this._drawEffect(x, y, cols, rows);\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    this._drawCell(x, y, cols, rows);\n                }\n            }\n        }\n        \n        this._isRunning = wasRunning;\n        return this;\n    }\n\n    /**\n     * Show the pattern (expand from center)\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    show(callback) {\n        this._isCollapsing = false;\n        if (callback) {\n            const originalCallback = this.options.onShow;\n            this.options.onShow = () => {\n                callback();\n                this.options.onShow = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Hide the pattern (collapse to center)\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    hide(callback) {\n        this._isCollapsing = true;\n        if (callback) {\n            const originalCallback = this.options.onHide;\n            this.options.onHide = () => {\n                callback();\n                this.options.onHide = originalCallback;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * Toggle between show and hide\n     * @param {Function} [callback] - Called when animation completes\n     * @returns {Borealis} this instance for chaining\n     */\n    toggle(callback) {\n        if (this._isCollapsing) {\n            return this.show(callback);\n        } else {\n            return this.hide(callback);\n        }\n    }\n\n    /**\n     * Check if currently visible (not collapsed)\n     * @returns {boolean}\n     */\n    isVisible() {\n        return !this._isCollapsing && this._collapseProgress === 0;\n    }\n\n    /**\n     * Check if currently hidden (fully collapsed)\n     * @returns {boolean}\n     */\n    isHidden() {\n        return this._isCollapsing && this._collapseProgress >= 1 + this.options.collapseWaveWidth;\n    }\n\n    /**\n     * Set a single option\n     * @param {string} key - Option key\n     * @param {*} value - Option value\n     * @returns {Borealis} this instance for chaining\n     */\n    setOption(key, value) {\n        // Handle effect as special case (use setEffect instead)\n        if (key === 'effect') {\n            if (typeof value === 'object') {\n                return this.setEffect(value.type, value);\n            }\n            return this;\n        }\n        \n        this.options[key] = value;\n        \n        // Handle special cases that need resize/recalculation\n        const needsResize = [\n            'density', 'dotSize', 'solidPattern', 'patternAurora', \n            'maxOpacity', 'minOpacity'\n        ];\n        \n        if (needsResize.includes(key)) {\n            this._updateDensity(this.options.density);\n            this._resize();\n        }\n        \n        return this;\n    }\n\n    /**\n     * Set effect type and options\n     * @param {string} type - Effect type: 'none', 'wave', or 'twinkle'\n     * @param {Object} [effectOptions] - Effect-specific options\n     * @returns {Borealis} this instance for chaining\n     */\n    setEffect(type, effectOptions = {}) {\n        // Update effect type\n        if (type) {\n            this.options.effect.type = type;\n        }\n        \n        // Merge effect options\n        Object.keys(effectOptions).forEach(key => {\n            if (key !== 'type') {\n                this.options.effect[key] = effectOptions[key];\n            }\n        });\n        \n        // Update internal computed values\n        this._updateTwinkleSettings();\n        this._updateDeadzone();\n        this._resize();\n        \n        return this;\n    }\n\n    /**\n     * Get current effect configuration\n     * @returns {Object} Effect configuration with type and options\n     */\n    getEffect() {\n        return { ...this.options.effect };\n    }\n\n    /**\n     * Set multiple options at once\n     * @param {Object} options - Options object\n     * @returns {Borealis} this instance for chaining\n     */\n    setOptions(options) {\n        Object.keys(options).forEach(key => {\n            this.setOption(key, options[key]);\n        });\n        return this;\n    }\n\n    /**\n     * Get current options\n     * @returns {Object} Current options\n     */\n    getOptions() {\n        return { ...this.options };\n    }\n\n    /**\n     * Get a specific option value\n     * @param {string} key - Option key\n     * @returns {*} Option value\n     */\n    getOption(key) {\n        return this.options[key];\n    }\n\n    /**\n     * Destroy the instance and clean up\n     */\n    destroy() {\n        this.stop();\n        window.removeEventListener('resize', this._resize);\n        \n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n        \n        this.canvas = null;\n        this.ctx = null;\n        this.noise = null;\n    }\n}\n\nexport default Borealis;\n"],"names":["SimplexNoise","constructor","seed","Math","random","this","p","Uint8Array","i","j","perm","noise2D","x","y","F2","sqrt","G2","s","floor","t","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","grad","hash","h","u","v","n0","n1","n2","t0","t1","t2","Borealis","defaultOptions","container","document","body","width","height","fullscreen","zIndex","initiallyHidden","className","background","density","dotSize","solidPattern","densityMinCell","densityMaxCell","densityMinGap","densityMaxGap","patternScale","patternAurora","warpScale","warpAmount","animationSpeed","ridgePower","minOpacity","maxOpacity","waveFrequency","waveAmplitude","effect","type","aurora","deadzone","speed","chance","intensity","delayMin","delayMax","combineSparkle","sparkleBaseOpacity","mode","combined","baseOpacity","twinkleSpeed","size","auroraColor1","auroraColor2","colorScale","collapseSpeed","collapseWaveWidth","autoStart","onShow","onHide","options","defaultEffect","userEffect","_init","canvas","createElement","style","cssText","insertBefore","firstChild","window","getComputedStyle","position","appendChild","ctx","getContext","noise","randomOffset","_cellSize","_gap","_gridSize","_sparkleMap","_animTime","_twinkleTime","_lastFrameTime","_sparkleWaiting","_sparkleWaitUntil","_diagPos","_isCollapsing","_collapseProgress","_isRunning","_animationId","_twinkleThreshold","_twinkleSpeedValue","_twinkleScaleValue","_deadzoneValue","_updateDensity","_updateTwinkleSettings","_updateDeadzone","_draw","bind","_resize","addEventListener","start","value","baseCell","sizeMultiplier","_generateSparkles","cols","rows","innerWidth","innerHeight","clientWidth","clientHeight","ceil","_offscreenCanvas","_offscreenCtx","time","delta","maxDiag","delay","clearRect","offCtx","imageData","createImageData","data","cellData","_calculateCellData","idx","r","g","b","round","opacity","putImageData","imageSmoothingEnabled","imageSmoothingQuality","drawImage","_drawEffect","_drawCell","_updateCollapse","requestAnimationFrame","wave1","sin","wave2","cos","warpX","warpY","noiseVal","ridge","abs","rawOpacity","pow","colorBlend","_applyCollapse","effectColor","effectOpacity","result","_calculateWaveEffect","color","_calculateTwinkleEffect","fillStyle","beginPath","arc","PI","fill","collapseResult","px","py","fillRect","centerX","centerY","distFromCenter","maxRadius","fadeZone","centerFade","cellDiag","distFromLine","waveProximity","max","smoothWaveProximity","hash1","rand1","hash2","rand2","phase","sparkleSpeed","twinkleWave","sparkle","colorRand","undefined","normalizedDist","fullDiagonalLength","min","diagStartX","diagEndX","currentLineLength","cylinderFade","posAlongLine","clampedPos","completeness","baseFade","baseScale","waveSpeed","smoothWave","waveIntensity","densityFactor","collapseAt","smoothFade","collapseEnd","performance","now","stop","cancelAnimationFrame","resize","redraw","wasRunning","show","callback","originalCallback","hide","toggle","isVisible","isHidden","setOption","key","setEffect","includes","effectOptions","Object","keys","forEach","getEffect","setOptions","getOptions","getOption","destroy","removeEventListener","parentNode","removeChild"],"mappings":"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"}